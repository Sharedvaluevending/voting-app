<%- include('partials/header') %>

<main class="chart-page">
  <div class="chart-header">
    <% if (typeof prevCoinId !== 'undefined' && prevCoinId) { %>
    <a href="/chart/<%= prevCoinId %>" class="btn btn-outline btn-sm chart-nav-btn" title="Previous coin">&#x2190; Prev</a>
    <% } %>
    <h1><%= coinName %> (<%= symbol %>) – Chart</h1>
    <% if (typeof nextCoinId !== 'undefined' && nextCoinId) { %>
    <a href="/chart/<%= nextCoinId %>" class="btn btn-outline btn-sm chart-nav-btn" title="Next coin">Next &#x2192;</a>
    <% } %>
    <a href="/trades" class="btn btn-outline btn-sm">Active Trades</a>
    <a href="/coin/<%= coinId %>" class="btn btn-outline btn-sm">Back to <%= coinName %></a>
  </div>

  <% if (entry != null || sl != null || tp1 != null || tp2 != null || tp3 != null) { %>
  <div class="trade-levels-overlay">
    <div class="trade-levels-title">Trade Levels – drawn on chart</div>
    <div class="trade-levels-grid">
      <% if (tp3 != null) { %><div class="level-row tp"><span class="level-name">TP3</span><span class="level-price">$<%= tp3.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 6 }) %></span></div><% } %>
      <% if (tp2 != null) { %><div class="level-row tp"><span class="level-name">TP2</span><span class="level-price">$<%= tp2.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 6 }) %></span></div><% } %>
      <% if (tp1 != null) { %><div class="level-row tp"><span class="level-name">TP1</span><span class="level-price">$<%= tp1.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 6 }) %></span></div><% } %>
      <% if (entry != null) { %><div class="level-row entry"><span class="level-name">Entry</span><span class="level-price">$<%= entry.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 6 }) %></span></div><% } %>
      <% if (sl != null) { %>
        <div class="level-row sl">
          <span class="level-name">SL</span>
          <span class="level-price">$<%= sl.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 6 }) %></span>
          <% if (typeof originalSl !== 'undefined' && originalSl != null && originalSl !== sl) { %>
            <span class="level-original">(orig: <s>$<%= originalSl.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 6 }) %></s>)</span>
          <% } %>
        </div>
      <% } %>
    </div>
    <div class="chart-actions-bar" id="chart-actions-bar"<%= (typeof tradeActions === 'undefined' || !tradeActions || tradeActions.length === 0) ? ' style="display:none;"' : '' %>>
      <% if (typeof tradeActions !== 'undefined' && tradeActions && tradeActions.length > 0) {
        var latestByType = {};
        tradeActions.forEach(function(a) { if (a.type) latestByType[a.type] = a; });
        var deduped = Object.values(latestByType);
        deduped.forEach(function(a) { %>
          <%
            var chartDisplayVal = '';
            if (['BE','TS','LOCK'].indexOf(a.type) >= 0 && a.newValue != null) {
              chartDisplayVal = ' $' + (typeof formatPrice !== 'undefined' ? formatPrice(a.newValue) : a.newValue);
            } else if (['EXIT','PP','RP'].indexOf(a.type) >= 0 && a.marketPrice != null) {
              chartDisplayVal = ' @$' + (typeof formatPrice !== 'undefined' ? formatPrice(a.marketPrice) : a.marketPrice);
            }
          %>
          <span class="action-badge action-<%= (a.type || '').toLowerCase() %>" title="<%= a.description || '' %>"><%= (a.type || '?') + chartDisplayVal %> <%= a.timestamp ? new Date(a.timestamp).toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'}) : '' %></span>
        <% }); %>
      <% } %>
    </div>
  </div>
  <% } %>

  <!-- TradingView-style toolbar: timeframe + drawing tools + toggles -->
  <div class="chart-toolbar chart-toolbar-tv" id="chart-toolbar">
    <div class="chart-toolbar-row chart-toolbar-row-1">
      <div class="tf-selector" id="tf-selector">
        <button class="tf-btn" data-tf="15m">15m</button>
        <button class="tf-btn tf-active" data-tf="1h">1H</button>
        <button class="tf-btn" data-tf="4h">4H</button>
        <button class="tf-btn" data-tf="1d">1D</button>
        <button class="tf-btn" data-tf="1w">1W</button>
      </div>
      <button type="button" class="draw-tools-toggle" id="draw-tools-toggle" aria-label="Drawing tools">
        <svg width="20" height="20" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none"><path d="M12 5v14M5 12h14"/></svg>
        <span class="draw-tools-toggle-text">Tools</span>
      </button>
    </div>
    <div class="chart-toolbar-row chart-toolbar-row-2">
      <div class="draw-tools" id="draw-tools">
        <button class="tool-btn tool-active" data-tool="cursor" title="Select">
          <svg width="18" height="18" viewBox="0 0 16 16" fill="currentColor"><path d="M3 1l10 6.5L8.5 9l-2 5.5L3 1z"/></svg>
        </button>
        <button class="tool-btn" data-tool="trendline" title="Trend Line">
          <svg width="18" height="18" viewBox="0 0 16 16" stroke="currentColor" stroke-width="2"><line x1="2" y1="13" x2="14" y2="3"/></svg>
        </button>
        <button class="tool-btn" data-tool="hline" title="Horizontal Line">
          <svg width="18" height="18" viewBox="0 0 16 16" stroke="currentColor" stroke-width="2"><line x1="1" y1="8" x2="15" y2="8"/></svg>
        </button>
        <button class="tool-btn" data-tool="rect" title="Rectangle">
          <svg width="18" height="18" viewBox="0 0 16 16" stroke="currentColor" stroke-width="1.5" fill="none"><rect x="2" y="3" width="12" height="10" rx="1"/></svg>
        </button>
        <button class="tool-btn" data-tool="fibdraw" title="Fibonacci">
          <svg width="18" height="18" viewBox="0 0 16 16" stroke="currentColor" fill="none" stroke-width="1.2"><line x1="1" y1="3" x2="15" y2="3" stroke-dasharray="2,2"/><line x1="1" y1="6.5" x2="15" y2="6.5" stroke-dasharray="2,2"/><line x1="1" y1="10" x2="15" y2="10" stroke-dasharray="2,2"/><line x1="1" y1="13" x2="15" y2="13" stroke-dasharray="2,2"/></svg>
        </button>
        <button class="tool-btn" data-tool="ray" title="Ray">
          <svg width="18" height="18" viewBox="0 0 16 16" stroke="currentColor" stroke-width="2"><line x1="2" y1="12" x2="14" y2="5"/><polygon points="14,5 10,5.5 12.5,7.5" fill="currentColor" stroke="none"/></svg>
        </button>
        <div class="toolbar-divider-vert"></div>
        <div class="draw-color-picker" id="draw-color-picker" title="Line color">
          <input type="color" id="draw-color-input" value="#f59e0b" title="Pick color">
          <span class="draw-color-swatches" id="draw-color-swatches">
            <span class="color-swatch" data-color="#f59e0b" style="background:#f59e0b"></span>
            <span class="color-swatch" data-color="#3b82f6" style="background:#3b82f6"></span>
            <span class="color-swatch" data-color="#22c55e" style="background:#22c55e"></span>
            <span class="color-swatch" data-color="#ef4444" style="background:#ef4444"></span>
            <span class="color-swatch" data-color="#a78bfa" style="background:#a78bfa"></span>
            <span class="color-swatch" data-color="#06b6d4" style="background:#06b6d4"></span>
          </span>
        </div>
        <button class="tool-btn tool-btn-danger" data-tool="delete" id="draw-delete-btn" title="Delete" disabled style="opacity:0.5;cursor:not-allowed;">
          <svg width="18" height="18" viewBox="0 0 16 16" stroke="currentColor" stroke-width="2" fill="none"><path d="M3 4h10v10H3zM6 4V2h4v2M6 7v4M10 7v4"/></svg>
        </button>
        <button class="tool-btn tool-btn-danger" data-tool="clear" title="Clear all">
          <svg width="18" height="18" viewBox="0 0 16 16" stroke="currentColor" stroke-width="2" fill="none"><line x1="4" y1="4" x2="12" y2="12"/><line x1="12" y1="4" x2="4" y2="12"/></svg>
        </button>
      </div>
    </div>
    <div class="chart-toolbar-row chart-toolbar-row-3">
      <div class="chart-toggles">
        <label class="toggle-label"><input type="checkbox" id="toggle-fib" checked> <span class="toggle-text">Fib</span></label>
        <label class="toggle-label"><input type="checkbox" id="toggle-badges" checked> <span class="toggle-text">Badges</span></label>
        <label class="toggle-label"><input type="checkbox" id="toggle-patterns" checked> <span class="toggle-text">Patterns</span></label>
        <label class="toggle-label"><input type="checkbox" id="toggle-chart-patterns" checked> <span class="toggle-text">Chart Pat.</span></label>
        <label class="toggle-label"><input type="checkbox" id="toggle-sr" checked> <span class="toggle-text">S/R</span></label>
        <label class="toggle-label"><input type="checkbox" id="toggle-poc" checked> <span class="toggle-text">POC</span></label>
        <% if (typeof tradeId !== 'undefined' && tradeId) { %>
        <label class="toggle-label"><input type="checkbox" id="toggle-trade" checked> <span class="toggle-text">Trade</span></label>
        <% } %>
      </div>
    </div>
  </div>

  <!-- Lightweight Charts (primary – with trade level lines) -->
  <div class="chart-container" id="lw-chart-container" style="display:none;">
    <div id="lw-chart" style="width:100%;height:100%;"></div>
    <div class="candle-countdown-wrap" style="position:absolute;top:8px;right:12px;z-index:6;text-align:right;pointer-events:none;padding:6px 10px;background:rgba(15,23,42,0.85);border:1px solid #334155;border-radius:6px;">
      <div class="candle-countdown-label" style="font-size:10px;color:#6b7280;margin-bottom:2px;text-transform:uppercase;letter-spacing:0.5px;">Candle closes in</div>
      <div id="candle-countdown" style="font-size:14px;font-weight:700;color:#e5e7eb;font-variant-numeric:tabular-nums;"></div>
    </div>
    <canvas id="draw-overlay" style="position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:5;"></canvas>
  </div>

  <!-- TradingView widget (fallback – always works) -->
  <div class="chart-container" id="tv-chart-container">
    <div id="tv-loading" style="display:flex;align-items:center;justify-content:center;height:100%;color:#6b7280;font-size:14px;">Loading chart...</div>
    <div class="tradingview-widget-container" id="tv-widget-wrap" style="width:100%;height:100%;display:none;">
      <div id="tradingview_widget" style="width:100%;height:100%;"></div>
    </div>
  </div>

  <!-- Chart Pattern Info Panel (populated via JS) -->
  <div class="chart-pattern-panel" id="chart-pattern-panel" style="display:none;">
    <div class="chart-pattern-panel-title">Chart Patterns Detected</div>
    <div class="chart-pattern-panel-list" id="chart-pattern-list"></div>
  </div>

  <% if (tradeId) { %>
  <div class="chart-marker-legend">
    <span style="color:#6b7280;font-weight:600;">Chart Markers:</span>
    <span class="legend-item"><span class="legend-dot" style="background:#10b981;"></span> BE (Breakeven)</span>
    <span class="legend-item"><span class="legend-dot" style="background:#3b82f6;"></span> TS (Trailing Stop)</span>
    <span class="legend-item"><span class="legend-dot" style="background:#38bdf8;"></span> LOCK (Profit Lock)</span>
    <span class="legend-item"><span class="legend-dot" style="background:#f87171;"></span> EXIT</span>
    <span class="legend-item"><span class="legend-dot" style="background:#a78bfa;"></span> PP (Partial Profit)</span>
    <span class="legend-item"><span class="legend-dot" style="background:#fbbf24;"></span> RP (Reduce Position)</span>
  </div>
  <% } %>
</main>

<style>
.chart-page { padding: 1rem; max-width: 100%; box-sizing: border-box; }
.chart-header { display: flex; align-items: center; justify-content: flex-start; flex-wrap: wrap; gap: 0.75rem; margin-bottom: 1rem; }
.chart-header h1 { margin: 0; font-size: 1.25rem; color: #e5e7eb; }
.trade-levels-overlay { margin-bottom: 1rem; padding: 0.75rem 1rem; background: rgba(15,23,42,0.95); border: 1px solid #334155; border-radius: 8px; }
.trade-levels-title { font-size: 11px; color: #6b7280; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 0.5rem; }
.trade-levels-grid { display: flex; flex-wrap: wrap; gap: 0.5rem 1rem; }
.level-row { font-size: 0.9rem; padding: 0.2rem 0.5rem; border-radius: 4px; }
.level-row.entry { background: rgba(59, 130, 246, 0.25); color: #93c5fd; }
.level-row.sl { background: rgba(239, 68, 68, 0.25); color: #fca5a5; }
.level-row.tp { background: rgba(34, 197, 94, 0.25); color: #86efac; }
.level-original { font-size: 11px; color: #6b7280; margin-left: 6px; }
.chart-actions-bar { display: flex; gap: 6px; flex-wrap: wrap; margin-top: 8px; }
.chart-actions-bar .action-badge { font-size: 10px; padding: 3px 8px; border-radius: 4px; font-weight: 600; }
.chart-actions-bar .action-badge.action-be { background: #064e3b; color: #10b981; }
.chart-actions-bar .action-badge.action-ts { background: #1e3a5f; color: #3b82f6; }
.chart-actions-bar .action-badge.action-lock { background: #0c4a6e; color: #38bdf8; }
.chart-actions-bar .action-badge.action-exit { background: #450a0a; color: #f87171; }
.chart-actions-bar .action-badge.action-pp { background: #2e1065; color: #a78bfa; }
.chart-actions-bar .action-badge.action-rp { background: #422006; color: #fbbf24; }
.chart-pattern-panel { margin-top: 8px; padding: 10px 14px; background: rgba(15,23,42,0.92); border: 1px solid #334155; border-radius: 8px; backdrop-filter: blur(8px); }
.chart-pattern-panel-title { font-size: 11px; color: #6b7280; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 8px; font-weight: 600; }
.chart-pattern-panel-list { display: flex; gap: 8px; flex-wrap: wrap; }
.chart-pattern-card { padding: 8px 12px; border-radius: 6px; font-size: 12px; min-width: 200px; max-width: 350px; }
.chart-pattern-card.bull { background: rgba(34,197,94,0.1); border-left: 3px solid #22c55e; }
.chart-pattern-card.bear { background: rgba(239,68,68,0.1); border-left: 3px solid #ef4444; }
.chart-pattern-card.neutral { background: rgba(234,179,8,0.1); border-left: 3px solid #eab308; }
.chart-pattern-card .cp-name { font-weight: 700; font-size: 13px; }
.chart-pattern-card .cp-meta { color: #9ca3af; font-size: 11px; margin-top: 3px; }
.chart-pattern-card .cp-target { color: #6b7280; font-size: 11px; margin-top: 2px; }
.chart-pattern-card .cp-wr { font-size: 10px; padding: 2px 6px; border-radius: 3px; font-weight: 600; display: inline-block; margin-top: 4px; }
.chart-pattern-card.bull .cp-wr { background: rgba(34,197,94,0.2); color: #22c55e; }
.chart-pattern-card.bear .cp-wr { background: rgba(239,68,68,0.2); color: #ef4444; }
.chart-pattern-card.neutral .cp-wr { background: rgba(234,179,8,0.2); color: #eab308; }
.chart-marker-legend { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 6px; padding: 6px 10px; background: rgba(15,23,42,0.8); border: 1px solid #1e293b; border-radius: 6px; font-size: 10px; color: #9ca3af; }
.chart-marker-legend .legend-item { display: flex; align-items: center; gap: 4px; }
.chart-marker-legend .legend-dot { width: 8px; height: 8px; border-radius: 50%; }
.chart-container { position: relative; width: 100%; height: calc(100vh - 320px); min-height: 400px; border-radius: 8px; overflow: hidden; background: #0f172a; }
.chart-toolbar-tv { display: flex; flex-direction: column; gap: 8px; margin-bottom: 8px; }
.chart-toolbar-row { display: flex; align-items: center; gap: 6px; flex-wrap: wrap; }
.chart-toolbar-row-1 { justify-content: space-between; }
.tf-selector { display: flex; gap: 4px; }
.tf-btn { background: rgba(30,41,59,0.8); border: 1px solid #334155; color: #9ca3af; padding: 6px 14px; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.15s; }
.tf-btn:hover { background: rgba(51,65,85,0.8); color: #e5e7eb; }
.tf-btn.tf-active { background: rgba(59,130,246,0.25); border-color: #3b82f6; color: #93c5fd; }
.draw-tools-toggle { display: none; background: rgba(30,41,59,0.8); border: 1px solid #334155; color: #9ca3af; padding: 8px 12px; border-radius: 6px; cursor: pointer; align-items: center; gap: 6px; font-size: 13px; }
.draw-tools { display: flex; gap: 4px; align-items: center; flex-wrap: wrap; }
.tool-btn { background: rgba(30,41,59,0.8); border: 1px solid #334155; color: #9ca3af; padding: 6px 8px; border-radius: 6px; cursor: pointer; transition: all 0.15s; display: flex; align-items: center; justify-content: center; min-width: 38px; min-height: 38px; }
.tool-btn:hover { background: rgba(51,65,85,0.8); color: #e5e7eb; }
.tool-btn.tool-active { background: rgba(59,130,246,0.25); border-color: #3b82f6; color: #93c5fd; }
.tool-btn-danger:hover { background: rgba(239,68,68,0.25); border-color: #ef4444; color: #fca5a5; }
.toolbar-divider-vert { width: 1px; height: 28px; background: #334155; margin: 0 4px; }
.draw-color-picker { display: flex; align-items: center; gap: 6px; }
.draw-color-picker input[type="color"] { width: 28px; height: 28px; padding: 2px; border: 1px solid #334155; border-radius: 6px; cursor: pointer; background: #1e293b; }
.draw-color-swatches { display: flex; gap: 4px; }
.color-swatch { width: 20px; height: 20px; border-radius: 4px; cursor: pointer; border: 2px solid transparent; }
.color-swatch:hover, .color-swatch.active { border-color: #fff; }
.chart-toggles { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
.toggle-label { display: flex; align-items: center; gap: 4px; cursor: pointer; font-size: 12px; color: #9ca3af; user-select: none; }
.toggle-label input[type="checkbox"] { accent-color: #3b82f6; width: 14px; height: 14px; cursor: pointer; }
.toggle-label:hover .toggle-text { color: #e5e7eb; }
/* Mobile: TradingView-style - tools always visible, larger touch targets */
@media (max-width: 768px) {
  .chart-page { padding: 0.5rem; }
  .chart-header h1 { font-size: 1.1rem; }
  .chart-container { min-height: 300px; height: calc(100vh - 380px); }
  .chart-toolbar-row-2 { order: 2; }
  .chart-toolbar-row-3 { order: 3; }
  .draw-tools-toggle { display: flex; min-height: 44px; padding: 10px 14px; }
  .draw-tools { display: none; gap: 6px; }
  .draw-tools.draw-tools-open { display: flex; padding: 10px 0; }
  .tool-btn { min-width: 44px; min-height: 44px; padding: 10px; }
  .tf-btn { padding: 10px 16px; min-height: 44px; font-size: 14px; }
  .toggle-label { padding: 8px 0; min-height: 44px; }
  .toggle-label input[type="checkbox"] { width: 20px; height: 20px; }
  .draw-color-picker input[type="color"] { width: 36px; height: 36px; }
  .color-swatch { width: 28px; height: 28px; }
}
</style>

<!-- Try Lightweight Charts first (draws price level lines on chart) -->
<script src="https://cdn.jsdelivr.net/npm/lightweight-charts@4.2.0/dist/lightweight-charts.standalone.production.js"></script>

<script>
(function() {
  var coinId = '<%= coinId %>';
  var tvSymbol = '<%= tvSymbol %>';
  var levels = {
    entry: <%- JSON.stringify(entry) %>,
    sl: <%- JSON.stringify(sl) %>,
    originalSl: <%- JSON.stringify(typeof originalSl !== 'undefined' ? originalSl : null) %>,
    tp1: <%- JSON.stringify(tp1) %>,
    tp2: <%- JSON.stringify(tp2) %>,
    tp3: <%- JSON.stringify(tp3) %>
  };
  var tradeId = <%- JSON.stringify(typeof tradeId !== 'undefined' ? tradeId : null) %>;
  var tradeDirection = <%- JSON.stringify(typeof direction !== 'undefined' ? direction : null) %>;
  var initialActions = <%- JSON.stringify(typeof tradeActions !== 'undefined' ? tradeActions : []) %>;
  var chartRef = { chart: null, series: null, volumeSeries: null, slLine: null, origSlLine: null, priceLines: [], fibLines: [], srLines: [], pocLines: [], candleTimes: [] };
  var currentTF = '1h';
  var showFib = true;
  var showBadges = true;
  var showPatterns = true;
  var showChartPatterns = true;
  var showSR = true;
  var showPOC = true;
  var showTradeLevels = true;
  var srLevels = { support: null, resistance: null };
  var pocLevel = null;
  var lastPatterns = [];
  var lastChartPatterns = [];
  var chartPatternSeries = [];  // line series for chart pattern trendlines
  var drawColor = '#f59e0b';

  // Action marker colors and shapes for Lightweight Charts
  var actionMarkerConfig = {
    BE:   { color: '#10b981', shape: 'arrowUp',   position: 'belowBar', label: 'BE' },
    TS:   { color: '#3b82f6', shape: 'arrowUp',   position: 'belowBar', label: 'TS' },
    LOCK: { color: '#38bdf8', shape: 'arrowUp',   position: 'belowBar', label: 'LOCK' },
    EXIT: { color: '#f87171', shape: 'arrowDown', position: 'aboveBar', label: 'EXIT' },
    PP:   { color: '#a78bfa', shape: 'arrowDown', position: 'aboveBar', label: 'PP' },
    RP:   { color: '#fbbf24', shape: 'arrowDown', position: 'aboveBar', label: 'RP' }
  };

  // Snap an action timestamp to the nearest candle time
  function snapToCandle(actionTimeMs) {
    if (!chartRef.candleTimes || chartRef.candleTimes.length === 0) return null;
    var actionSec = Math.floor(actionTimeMs / 1000);
    var best = chartRef.candleTimes[0];
    var bestDiff = Math.abs(actionSec - best);
    for (var i = 1; i < chartRef.candleTimes.length; i++) {
      var diff = Math.abs(actionSec - chartRef.candleTimes[i]);
      if (diff < bestDiff) { best = chartRef.candleTimes[i]; bestDiff = diff; }
    }
    return best;
  }

  // Build and apply chart markers from actions array
  // Only shows the MOST RECENT action of each type to keep the chart clean.
  // e.g. if stop was trailed 5 times, only the latest TS marker is shown.
  function applyActionMarkers(actions) {
    if (!chartRef.series) return;

    var markers = [];

    // Add action badge markers (if badges enabled and actions exist)
    if (showBadges && actions && actions.length > 0) {
      // Deduplicate: keep only the latest action of each type
      var latestByType = {};
      for (var i = 0; i < actions.length; i++) {
        var a = actions[i];
        if (!a.type || !a.timestamp) continue;
        // Always overwrite — actions array is chronological so last one wins
        latestByType[a.type] = a;
      }
      var deduped = Object.keys(latestByType).map(function(k) { return latestByType[k]; });

      for (var j = 0; j < deduped.length; j++) {
        var act = deduped[j];
        var cfg = actionMarkerConfig[act.type];
        if (!cfg) continue;
        var ts = snapToCandle(new Date(act.timestamp).getTime());
        if (ts == null) continue;
        var priceInfo = '';
        if (['BE','TS','LOCK'].indexOf(act.type) >= 0 && act.newValue != null) {
          priceInfo = ' $' + (act.newValue >= 1 ? act.newValue.toFixed(2) : act.newValue.toFixed(6));
        } else if (['EXIT','PP','RP'].indexOf(act.type) >= 0 && act.marketPrice != null) {
          priceInfo = ' @$' + (act.marketPrice >= 1 ? act.marketPrice.toFixed(2) : act.marketPrice.toFixed(6));
        }
        markers.push({
          time: ts,
          position: cfg.position,
          color: cfg.color,
          shape: cfg.shape,
          text: cfg.label + priceInfo
        });
      }
    }

    // Add pattern markers if enabled (independent of action badges)
    if (showPatterns && lastPatterns && lastPatterns.length > 0) {
      for (var p = 0; p < lastPatterns.length; p++) {
        var pat = lastPatterns[p];
        if (!pat.time) continue;
        var isBull = pat.direction === 'BULL';
        var isBear = pat.direction === 'BEAR';
        markers.push({
          time: pat.time,
          position: isBull ? 'belowBar' : isBear ? 'aboveBar' : 'inBar',
          color: isBull ? '#10b981' : isBear ? '#ef4444' : '#6b7280',
          shape: isBull ? 'arrowUp' : isBear ? 'arrowDown' : 'circle',
          text: pat.name
        });
      }
    }

    // Sort by time (required by Lightweight Charts) and apply
    if (markers.length > 0) {
      markers.sort(function(a, b) { return a.time - b.time; });
    }
    try { chartRef.series.setMarkers(markers); } catch(e) { console.warn('setMarkers error:', e); }
  }

  var lwContainer = document.getElementById('lw-chart-container');
  var tvContainer = document.getElementById('tv-chart-container');
  var tfSelector = document.getElementById('tf-selector');

  // TradingView interval map for timeframe selector
  var tvIntervalMap = { '15m': '15', '1h': '60', '4h': '240', '1d': 'D', '1w': 'W' };
  var tfIntervalSec = { '15m': 900, '1h': 3600, '4h': 14400, '1d': 86400, '1w': 604800 };
  var tfLabel = { '15m': '15m', '1h': '1H', '4h': '4H', '1d': '1D', '1w': '1W' };
  var countdownIntervalId = null;

  function updateCandleCountdown() {
    var el = document.getElementById('candle-countdown');
    var labelEl = document.querySelector('.candle-countdown-label');
    if (!el || !chartRef.candleTimes || chartRef.candleTimes.length === 0) return;
    var lastTime = chartRef.candleTimes[chartRef.candleTimes.length - 1];
    var intervalSec = tfIntervalSec[currentTF] || 3600;
    var nextCandleSec = lastTime + intervalSec;
    var nowSec = Math.floor(Date.now() / 1000);
    var remaining = nextCandleSec - nowSec;
    if (remaining <= 0) {
      el.textContent = '00:00';
      if (labelEl) labelEl.textContent = 'Next ' + (tfLabel[currentTF] || currentTF) + ' candle';
      return;
    }
    var m = Math.floor(remaining / 60);
    var s = remaining % 60;
    el.textContent = (m < 10 ? '0' : '') + m + ':' + (s < 10 ? '0' : '') + s;
    if (labelEl) labelEl.textContent = 'Candle closes in';
  }

  function startCandleCountdown() {
    if (countdownIntervalId) clearInterval(countdownIntervalId);
    updateCandleCountdown();
    countdownIntervalId = setInterval(updateCandleCountdown, 1000);
  }

  function stopCandleCountdown() {
    if (countdownIntervalId) { clearInterval(countdownIntervalId); countdownIntervalId = null; }
    var el = document.getElementById('candle-countdown');
    var labelEl = document.querySelector('.candle-countdown-label');
    if (el) el.textContent = '';
    if (labelEl) labelEl.textContent = '';
  }

  var lastCandleData = null;
  var candleAnimationIntervalId = null;

  function updateLastCandleWithPrice(price) {
    if (!chartRef.series || !lastCandleData || !chartRef.chart) return;
    var nowSec = Math.floor(Date.now() / 1000);
    var intervalSec = tfIntervalSec[currentTF] || 3600;
    var nextCandleSec = lastCandleData.time + intervalSec;
    if (nowSec >= nextCandleSec) {
      loadCandles(currentTF, { preserveView: true });
      return;
    }
    var high = Math.max(lastCandleData.high, price);
    var low = Math.min(lastCandleData.low, price);
    var bar = { time: lastCandleData.time, open: lastCandleData.open, high: high, low: low, close: price };
    lastCandleData = bar;
    try { chartRef.series.update(bar); } catch(e) {}
  }

  function startCandleAnimation() {
    if (candleAnimationIntervalId) clearInterval(candleAnimationIntervalId);
    candleAnimationIntervalId = setInterval(function() {
      if (!chartRef.chart || !chartRef.series || tvFallbackAttempted) return;
      fetch('/api/prices', { credentials: 'same-origin' })
        .then(function(r) { return r.ok ? r.json() : null; })
        .then(function(result) {
          if (!result || !result.success || !result.data) return;
          var p = result.data.find(function(x) { return x.id === coinId; });
          if (p && p.price != null) updateLastCandleWithPrice(Number(p.price));
        })
        .catch(function() {});
    }, 6000);
  }

  function stopCandleAnimation() {
    if (candleAnimationIntervalId) { clearInterval(candleAnimationIntervalId); candleAnimationIntervalId = null; }
  }

  // ---- Fallback: show TradingView widget ----
  var tvFallbackAttempted = false;
  function showTradingViewFallback() {
    if (tvFallbackAttempted) return; // prevent double-loading
    tvFallbackAttempted = true;
    stopCandleCountdown();
    stopCandleAnimation();
    lwContainer.style.display = 'none';
    tvContainer.style.display = '';
    if (tfSelector) tfSelector.style.display = 'none';
    var tvLoading = document.getElementById('tv-loading');
    var tvWrap = document.getElementById('tv-widget-wrap');
    var script = document.createElement('script');
    script.src = 'https://s3.tradingview.com/tv.js';
    script.onload = function() {
      try {
        if (tvLoading) tvLoading.style.display = 'none';
        if (tvWrap) tvWrap.style.display = '';
        new TradingView.widget({
          container_id: 'tradingview_widget',
          autosize: true,
          symbol: tvSymbol,
          interval: tvIntervalMap[currentTF] || '60',
          timezone: 'Etc/UTC',
          theme: 'dark',
          style: '1',
          locale: 'en',
          toolbar_bg: '#0f172a',
          enable_publishing: false,
          hide_side_toolbar: false,
          allow_symbol_change: true,
          save_image: false,
          show_popup_button: true,
          popup_width: '1000',
          popup_height: '650'
        });
      } catch (tvErr) {
        console.error('TradingView widget failed:', tvErr);
        if (tvLoading) { tvLoading.textContent = 'Chart unavailable. Please try refreshing the page.'; tvLoading.style.display = 'flex'; }
      }
    };
    script.onerror = function() {
      console.error('TradingView script failed to load');
      if (tvLoading) { tvLoading.textContent = 'Chart unavailable. Please try refreshing the page.'; tvLoading.style.display = 'flex'; }
    };
    document.body.appendChild(script);
  }

  // ---- Primary: Lightweight Charts with trade levels ----
  if (typeof LightweightCharts === 'undefined') {
    console.warn('Lightweight Charts not loaded, falling back to TradingView');
    showTradingViewFallback();
    return;
  }

  function addPriceLines() {
    if (!chartRef.series) return;
    if (chartRef.slLine) { try { chartRef.series.removePriceLine(chartRef.slLine); } catch(e) {} chartRef.slLine = null; }
    if (chartRef.origSlLine) { try { chartRef.series.removePriceLine(chartRef.origSlLine); } catch(e) {} chartRef.origSlLine = null; }
    chartRef.priceLines.forEach(function(pl) {
      try { chartRef.series.removePriceLine(pl); } catch(e) {}
    });
    chartRef.priceLines = [];
    chartRef.fibLines.forEach(function(pl) {
      try { chartRef.series.removePriceLine(pl); } catch(e) {}
    });
    chartRef.fibLines = [];
    chartRef.srLines.forEach(function(pl) {
      try { chartRef.series.removePriceLine(pl); } catch(e) {}
    });
    chartRef.srLines = [];
    chartRef.pocLines.forEach(function(pl) {
      try { chartRef.series.removePriceLine(pl); } catch(e) {}
    });
    chartRef.pocLines = [];

    var lineOpts = { lineWidth: 2, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: true };
    if (showTradeLevels) {
      if (levels.sl != null) {
        chartRef.slLine = chartRef.series.createPriceLine(Object.assign({}, lineOpts, { price: levels.sl, color: '#ef4444', title: 'SL' }));
      }
      if (levels.originalSl != null && levels.originalSl !== levels.sl) {
        chartRef.origSlLine = chartRef.series.createPriceLine(Object.assign({}, lineOpts, { price: levels.originalSl, color: '#78716c', title: 'Orig SL', lineStyle: LightweightCharts.LineStyle.Dotted }));
      }
      if (levels.entry != null) {
        chartRef.priceLines.push(chartRef.series.createPriceLine(Object.assign({}, lineOpts, { price: levels.entry, color: '#3b82f6', title: 'Entry' })));
      }
      if (levels.tp1 != null) {
        chartRef.priceLines.push(chartRef.series.createPriceLine(Object.assign({}, lineOpts, { price: levels.tp1, color: '#22c55e', title: 'TP1' })));
      }
      if (levels.tp2 != null) {
        chartRef.priceLines.push(chartRef.series.createPriceLine(Object.assign({}, lineOpts, { price: levels.tp2, color: '#22c55e', title: 'TP2' })));
      }
      if (levels.tp3 != null) {
        chartRef.priceLines.push(chartRef.series.createPriceLine(Object.assign({}, lineOpts, { price: levels.tp3, color: '#22c55e', title: 'TP3' })));
      }
    } else {
      chartRef.slLine = null;
      chartRef.origSlLine = null;
    }
    // Fibonacci levels (dotted, subtle) — stored separately for toggling
    <% if (fibLevels) { %>
    if (showFib) {
      var fibOpts = Object.assign({}, lineOpts, { lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dotted });
      <% if (fibLevels.fib236) { %>chartRef.fibLines.push(chartRef.series.createPriceLine(Object.assign({}, fibOpts, { price: <%= fibLevels.fib236 %>, color: '#a78bfa', title: 'Fib 23.6%' })));<% } %>
      <% if (fibLevels.fib382) { %>chartRef.fibLines.push(chartRef.series.createPriceLine(Object.assign({}, fibOpts, { price: <%= fibLevels.fib382 %>, color: '#a78bfa', title: 'Fib 38.2%' })));<% } %>
      <% if (fibLevels.fib500) { %>chartRef.fibLines.push(chartRef.series.createPriceLine(Object.assign({}, fibOpts, { price: <%= fibLevels.fib500 %>, color: '#c084fc', title: 'Fib 50%' })));<% } %>
      <% if (fibLevels.fib618) { %>chartRef.fibLines.push(chartRef.series.createPriceLine(Object.assign({}, fibOpts, { price: <%= fibLevels.fib618 %>, color: '#e879f9', title: 'Fib 61.8%' })));<% } %>
    }
    <% } %>
    // Support/Resistance from engine (toggleable)
    if (showSR && srLevels.support != null && srLevels.resistance != null) {
      var srOpts = Object.assign({}, lineOpts, { lineWidth: 1.5, lineStyle: LightweightCharts.LineStyle.Solid });
      chartRef.srLines.push(chartRef.series.createPriceLine(Object.assign({}, srOpts, { price: srLevels.support, color: '#22c55e', title: 'Support' })));
      chartRef.srLines.push(chartRef.series.createPriceLine(Object.assign({}, srOpts, { price: srLevels.resistance, color: '#ef4444', title: 'Resistance' })));
    }
    // POC (Point of Control) - volume profile
    if (showPOC && pocLevel != null) {
      var pocOpts = Object.assign({}, lineOpts, { lineWidth: 1.5, lineStyle: LightweightCharts.LineStyle.Dotted });
      chartRef.pocLines.push(chartRef.series.createPriceLine(Object.assign({}, pocOpts, { price: pocLevel, color: '#a78bfa', title: 'POC' })));
    }
  }

  function toggleSRLines(visible) {
    showSR = visible;
    if (!chartRef.series) return;
    if (!visible) {
      chartRef.srLines.forEach(function(pl) {
        try { chartRef.series.removePriceLine(pl); } catch(e) {}
      });
      chartRef.srLines = [];
    } else {
      addPriceLines();
    }
  }

  function togglePOCLines(visible) {
    showPOC = visible;
    if (!chartRef.series) return;
    if (!visible) {
      chartRef.pocLines.forEach(function(pl) {
        try { chartRef.series.removePriceLine(pl); } catch(e) {}
      });
      chartRef.pocLines = [];
    } else {
      addPriceLines();
    }
  }

  function toggleTradeLevels(visible) {
    showTradeLevels = visible;
    if (!chartRef.series) return;
    if (!visible) {
      if (chartRef.slLine) { try { chartRef.series.removePriceLine(chartRef.slLine); } catch(e) {} chartRef.slLine = null; }
      if (chartRef.origSlLine) { try { chartRef.series.removePriceLine(chartRef.origSlLine); } catch(e) {} chartRef.origSlLine = null; }
      chartRef.priceLines.forEach(function(pl) { try { chartRef.series.removePriceLine(pl); } catch(e) {} });
      chartRef.priceLines = [];
    } else {
      addPriceLines();
    }
  }

  // Toggle Fib lines on/off
  function toggleFibLines(visible) {
    showFib = visible;
    if (!chartRef.series) return;
    if (!visible) {
      chartRef.fibLines.forEach(function(pl) {
        try { chartRef.series.removePriceLine(pl); } catch(e) {}
      });
      chartRef.fibLines = [];
    } else {
      addPriceLines();
    }
  }

  // Toggle badge markers on/off
  function toggleBadges(visible) {
    showBadges = visible;
    if (!chartRef.series) return;
    // Re-apply markers (applyActionMarkers handles showBadges/showPatterns flags)
    applyActionMarkers(initialActions || []);
  }

  // =============================================
  //  CHART PATTERN TRENDLINES — draw/remove
  // =============================================
  function removeChartPatternLines() {
    for (var i = 0; i < chartPatternSeries.length; i++) {
      try { chartRef.chart.removeSeries(chartPatternSeries[i]); } catch(e) {}
    }
    chartPatternSeries = [];
  }

  function updateChartPatternPanel() {
    var panel = document.getElementById('chart-pattern-panel');
    var list = document.getElementById('chart-pattern-list');
    if (!panel || !list) return;
    if (!lastChartPatterns || lastChartPatterns.length === 0) {
      panel.style.display = 'none';
      return;
    }
    panel.style.display = '';
    var html = '';
    for (var i = 0; i < lastChartPatterns.length; i++) {
      var p = lastChartPatterns[i];
      var cls = p.direction === 'BULL' ? 'bull' : p.direction === 'BEAR' ? 'bear' : 'neutral';
      var dir = p.direction === 'BULL' ? 'Bullish' : p.direction === 'BEAR' ? 'Bearish' : 'Neutral';
      var targetStr = '';
      if (p.target) {
        targetStr = '<div class="cp-target">Target: $' + (p.target >= 1 ? p.target.toFixed(2) : p.target.toFixed(6)) + '</div>';
      }
      var wrStr = '';
      if (p.reliability && p.reliability.winRate) {
        wrStr = '<span class="cp-wr">' + Math.round(p.reliability.winRate * 100) + '% win rate | Tier ' + (p.reliability.tier || '?') + '</span>';
      }
      html += '<div class="chart-pattern-card ' + cls + '">' +
        '<div class="cp-name">' + p.name + '</div>' +
        '<div class="cp-meta">' + dir + ' ' + p.type + (p.completion != null ? ' | ' + p.completion + '% complete' : '') +
        (p.volumeConfirm ? ' | Vol ✓' : '') + '</div>' +
        targetStr + wrStr +
        '</div>';
    }
    list.innerHTML = html;
  }

  function renderChartPatterns() {
    removeChartPatternLines();
    updateChartPatternPanel();
    if (!showChartPatterns || !chartRef.chart || !lastChartPatterns || lastChartPatterns.length === 0) return;

    for (var pi = 0; pi < lastChartPatterns.length; pi++) {
      var pat = lastChartPatterns[pi];
      if (!pat.trendlines || pat.trendlines.length === 0) continue;

      var isBull = pat.direction === 'BULL';
      var isBear = pat.direction === 'BEAR';
      var lineColor = isBull ? 'rgba(34,197,94,0.7)' : isBear ? 'rgba(239,68,68,0.7)' : 'rgba(234,179,8,0.7)';

      for (var ti = 0; ti < pat.trendlines.length; ti++) {
        var tl = pat.trendlines[ti];
        if (!tl.startTime || !tl.endTime || !tl.startPrice || !tl.endPrice) continue;

        // Use line series for trendlines
        try {
          var lineSeries = chartRef.chart.addLineSeries({
            color: tl.label === 'neckline' ? 'rgba(251,191,36,0.8)' : lineColor,
            lineWidth: tl.label === 'neckline' ? 2 : 1.5,
            lineStyle: tl.label === 'neckline' ? 2 : 0, // 2=dashed, 0=solid
            crosshairMarkerVisible: false,
            lastValueVisible: false,
            priceLineVisible: false
          });
          var data = [
            { time: tl.startTime, value: tl.startPrice },
            { time: tl.endTime, value: tl.endPrice }
          ];
          // Ensure data is sorted by time
          data.sort(function(a, b) { return a.time - b.time; });
          lineSeries.setData(data);

          // Add pattern label as a marker on the last point
          if (ti === 0) {
            try {
              lineSeries.setMarkers([{
                time: data[data.length - 1].time,
                position: isBull ? 'belowBar' : 'aboveBar',
                color: isBull ? '#22c55e' : isBear ? '#ef4444' : '#eab308',
                shape: 'square',
                text: pat.name + (pat.completion != null ? ' ' + pat.completion + '%' : '')
              }]);
            } catch(me) {}
          }

          chartPatternSeries.push(lineSeries);
        } catch(e) {
          console.warn('Chart pattern line error:', e);
        }
      }

      // Draw target level as a dotted horizontal line if we have it
      if (pat.target && pat.trendlines.length > 0) {
        try {
          var lastTL = pat.trendlines[pat.trendlines.length - 1];
          if (lastTL.endTime) {
            var targetSeries = chartRef.chart.addLineSeries({
              color: isBull ? 'rgba(34,197,94,0.4)' : isBear ? 'rgba(239,68,68,0.4)' : 'rgba(234,179,8,0.4)',
              lineWidth: 1,
              lineStyle: 2, // dashed
              crosshairMarkerVisible: false,
              lastValueVisible: false,
              priceLineVisible: false
            });
            // Extend target line from pattern end to 20 candles ahead
            var extendTime = lastTL.endTime + (lastTL.endTime - (pat.trendlines[0].startTime || lastTL.startTime)) * 0.5;
            var targetData = [
              { time: lastTL.endTime, value: pat.target },
              { time: Math.max(extendTime, lastTL.endTime + 1), value: pat.target }
            ];
            targetData.sort(function(a, b) { return a.time - b.time; });
            targetSeries.setData(targetData);
            chartPatternSeries.push(targetSeries);
          }
        } catch(te) {
          console.warn('Target line error:', te);
        }
      }
    }
  }

  function loadCandles(tf, opts) {
    opts = opts || {};
    var preserveView = opts.preserveView === true;
    currentTF = tf;
    var tvLoading = document.getElementById('tv-loading');
    var fetchTimeout = setTimeout(function() {
      if (!chartRef.chart && tvLoading && tvLoading.style.display !== 'none') {
        console.warn('Chart fetch timeout, falling back to TradingView');
        showTradingViewFallback();
      }
    }, 15000);
    fetch('/api/candles/' + coinId + '?interval=' + tf)
      .then(function(r) {
        clearTimeout(fetchTimeout);
        if (!r.ok) return r.json().catch(function() { return { success: false }; });
        return r.json();
      })
      .then(function(data) {
        clearTimeout(fetchTimeout);
        if (!data || !data.success || !data.candles || data.candles.length === 0) {
          if (!chartRef.chart) showTradingViewFallback();
          return;
        }

        // Capture pattern data, chart patterns, S/R and POC from API (redraw per timeframe)
        lastPatterns = data.patterns || [];
        lastChartPatterns = data.chartPatterns || [];
        srLevels.support = data.support;
        srLevels.resistance = data.resistance;
        pocLevel = data.poc != null ? data.poc : null;

        if (!chartRef.chart) {
          // First load — create the chart (defer so container has layout/dimensions)
          lwContainer.style.display = '';
          tvContainer.style.display = 'none';
          if (tvLoading) tvLoading.style.display = 'none';
          var initChart = function() {
            try {
              var chartEl = document.getElementById('lw-chart');
              if (!chartEl) { showTradingViewFallback(); return; }

              // Ensure container has real dimensions before creating chart
              var containerRect = chartEl.getBoundingClientRect();
              var chartOpts = {
                layout: { background: { type: 'solid', color: '#0f172a' }, textColor: '#9ca3af' },
                grid: { vertLines: { color: '#1e293b' }, horzLines: { color: '#1e293b' } },
                timeScale: { timeVisible: true, secondsVisible: false, borderColor: '#334155', shiftVisibleRangeOnNewBar: false },
                rightPriceScale: { borderColor: '#334155', scaleMargins: { top: 0.1, bottom: 0.25 } }
              };
              if (containerRect.width > 0 && containerRect.height > 0) {
                chartOpts.autoSize = true;
              } else {
                chartOpts.width = Math.max(containerRect.width, 800);
                chartOpts.height = Math.max(containerRect.height, 400);
                chartOpts.autoSize = true;
              }
              var chart = LightweightCharts.createChart(chartEl, chartOpts);
              var series = chart.addCandlestickSeries({
                upColor: '#22c55e', downColor: '#ef4444',
                borderDownColor: '#ef4444', borderUpColor: '#22c55e',
                wickDownColor: '#ef4444', wickUpColor: '#22c55e'
              });
              series.setData(data.candles);
              if (data.volume && data.volume.length > 0) {
                var volSeries = chart.addHistogramSeries({
                  priceFormat: { type: 'volume' },
                  priceScaleId: ''
                });
                try { volSeries.priceScale().applyOptions({ scaleMargins: { top: 0.8, bottom: 0 }, borderVisible: false }); } catch (e) {}
                volSeries.setData(data.volume);
                chartRef.volumeSeries = volSeries;
              }
              chartRef.chart = chart;
              chartRef.series = series;
              chartRef.candleTimes = data.candles.map(function(c) { return c.time; });
              var lastC = data.candles[data.candles.length - 1];
              lastCandleData = lastC ? { time: lastC.time, open: lastC.open, high: lastC.high, low: lastC.low, close: lastC.close } : null;

              // Price lines and markers (non-critical — errors won't break chart)
              try { addPriceLines(); } catch(e) { console.warn('addPriceLines error:', e); }
              try { applyActionMarkers(initialActions || []); } catch(e) { console.warn('applyActionMarkers error:', e); }
              try { renderChartPatterns(); } catch(e) { console.warn('renderChartPatterns error:', e); }

              chart.timeScale().fitContent();
              startCandleCountdown();
              startCandleAnimation();
              // Set up drawing overlay after chart is ready
              setTimeout(function() { resizeDrawCanvas(); hookChartRedraw(); }, 100);
            } catch (chartErr) {
              console.error('Chart init error:', chartErr);
              showTradingViewFallback();
            }
          };
          if (typeof requestAnimationFrame === 'function') {
            requestAnimationFrame(function() { requestAnimationFrame(initChart); });
          } else {
            setTimeout(initChart, 0);
          }
        } else {
          // Timeframe switch or new-candle refresh — update data
          try {
            chartRef.series.setData(data.candles);
            chartRef.candleTimes = data.candles.map(function(c) { return c.time; });
            var lastC = data.candles[data.candles.length - 1];
            lastCandleData = lastC ? { time: lastC.time, open: lastC.open, high: lastC.high, low: lastC.low, close: lastC.close } : null;
            if (chartRef.volumeSeries && data.volume && data.volume.length > 0) {
              chartRef.volumeSeries.setData(data.volume);
            }
            try { addPriceLines(); } catch(e) { console.warn('addPriceLines error:', e); }
            try { applyActionMarkers(initialActions || []); } catch(e) { console.warn('applyActionMarkers error:', e); }
            try { renderChartPatterns(); } catch(e) { console.warn('renderChartPatterns error:', e); }
            if (!preserveView) chartRef.chart.timeScale().fitContent();
            startCandleCountdown();
            setTimeout(function() { renderDrawings(); }, 100);
          } catch (updateErr) {
            console.error('Chart update error:', updateErr);
          }
        }
      })
      .catch(function(err) {
        clearTimeout(fetchTimeout);
        console.error('Chart load error:', err);
        if (!chartRef.chart) showTradingViewFallback();
      });
  }

  // Timeframe button clicks
  var tfBtns = tfSelector ? tfSelector.querySelectorAll('.tf-btn') : [];
  for (var i = 0; i < tfBtns.length; i++) {
    tfBtns[i].addEventListener('click', function() {
      var tf = this.getAttribute('data-tf');
      if (tf === currentTF) return;
      for (var j = 0; j < tfBtns.length; j++) tfBtns[j].classList.remove('tf-active');
      this.classList.add('tf-active');
      loadCandles(tf);
    });
  }

  // Initial load — start immediately so chart loads even if drawing setup fails
  loadCandles('1h');

  // Poll for trade updates when tradeId present (stop moved, actions, etc.)
  if (tradeId && typeof fetch === 'function') {
    var slRow = document.querySelector('.trade-levels-overlay .level-row.sl');
    var slEl = slRow ? slRow.querySelector('.level-price') : null;
    var origEl = slRow ? slRow.querySelector('.level-original') : null;
    var actionsBar = document.getElementById('chart-actions-bar');
    function fmt(n) { return n >= 1 ? n.toFixed(2) : n.toFixed(6); }
    function priceStr(n) { return n >= 1 ? n.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 6}) : n.toFixed(6); }
    setInterval(function() {
      fetch((window.location.origin || '') + '/api/trades/active', { credentials: 'same-origin' })
        .then(function(r) { return r.ok ? r.json() : null; })
        .then(function(data) {
          if (!data || !data.success || !data.trades || !data.trades[tradeId]) return;
          var t = data.trades[tradeId];
          var newSl = t.stopLoss;
          var newOrig = t.originalStopLoss || newSl;
          if (newSl != null && (levels.sl !== newSl || levels.originalSl !== newOrig)) {
            levels.sl = newSl;
            levels.originalSl = newOrig;
            if (slEl) slEl.textContent = '$' + priceStr(newSl);
            if (slRow) {
              if (newOrig != null && newOrig !== newSl) {
                if (!origEl) {
                  origEl = document.createElement('span');
                  origEl.className = 'level-original';
                  slRow.appendChild(origEl);
                }
                origEl.textContent = '(orig: $' + priceStr(newOrig) + ')';
                origEl.style.display = '';
              } else if (origEl) origEl.style.display = 'none';
            }
            if (chartRef.series) {
              if (chartRef.slLine) { try { chartRef.series.removePriceLine(chartRef.slLine); } catch(e) {} chartRef.slLine = null; }
              if (chartRef.origSlLine) { try { chartRef.series.removePriceLine(chartRef.origSlLine); } catch(e) {} chartRef.origSlLine = null; }
              var lineOpts = { lineWidth: 2, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: true };
              chartRef.slLine = chartRef.series.createPriceLine(Object.assign({}, lineOpts, { price: newSl, color: '#ef4444', title: 'SL' }));
              if (newOrig != null && newOrig !== newSl)
                chartRef.origSlLine = chartRef.series.createPriceLine(Object.assign({}, lineOpts, { price: newOrig, color: '#78716c', title: 'Orig SL', lineStyle: LightweightCharts.LineStyle.Dotted }));
            }
          }
          if (t.actions && t.actions.length > 0) {
            // Update chart markers (deduplicated — only latest of each type shown)
            initialActions = t.actions;
            applyActionMarkers(t.actions);

            // Update badge bar (deduplicated — latest of each type)
            if (actionsBar) {
              var latestByType = {};
              t.actions.forEach(function(a) { if (a.type) latestByType[a.type] = a; });
              var deduped = Object.keys(latestByType).map(function(k) { return latestByType[k]; });
              var html = deduped.map(function(a) {
                var dv = '';
                if (['BE','TS','LOCK'].indexOf(a.type) >= 0 && a.newValue != null) {
                  dv = ' $' + fmt(a.newValue);
                } else if (['EXIT','PP','RP'].indexOf(a.type) >= 0 && a.marketPrice != null) {
                  dv = ' @$' + fmt(a.marketPrice);
                }
                var lbl = (a.type || '?') + dv + (a.timestamp ? ' ' + new Date(a.timestamp).toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'}) : '');
                return '<span class="action-badge action-' + (a.type || '').toLowerCase() + '" title="' + (a.description || '').replace(/"/g, '&quot;') + '">' + lbl + '</span>';
              }).join('');
              actionsBar.innerHTML = html;
              actionsBar.style.display = '';
            }
          }
        })
        .catch(function() {});
    }, 5000);
  }
  // ---- Toggle listeners and drawing tools (wrapped so chart load is never blocked) ----
  try {
  var toggleFibEl = document.getElementById('toggle-fib');
  if (toggleFibEl) toggleFibEl.addEventListener('change', function() { toggleFibLines(this.checked); });
  var toggleBadgesEl = document.getElementById('toggle-badges');
  if (toggleBadgesEl) toggleBadgesEl.addEventListener('change', function() { toggleBadges(this.checked); });
  var togglePatternsEl = document.getElementById('toggle-patterns');
  if (togglePatternsEl) togglePatternsEl.addEventListener('change', function() {
    showPatterns = this.checked;
    applyActionMarkers(initialActions || []);
  });
  var toggleChartPatternsEl = document.getElementById('toggle-chart-patterns');
  if (toggleChartPatternsEl) toggleChartPatternsEl.addEventListener('change', function() {
    showChartPatterns = this.checked;
    if (showChartPatterns) { renderChartPatterns(); } else { removeChartPatternLines(); }
  });
  var toggleSrEl = document.getElementById('toggle-sr');
  if (toggleSrEl) toggleSrEl.addEventListener('change', function() { toggleSRLines(this.checked); });
  var togglePocEl = document.getElementById('toggle-poc');
  if (togglePocEl) togglePocEl.addEventListener('change', function() { togglePOCLines(this.checked); });
  var toggleTradeEl = document.getElementById('toggle-trade');
  if (toggleTradeEl) toggleTradeEl.addEventListener('change', function() { toggleTradeLevels(this.checked); });
  var drawToolsToggle = document.getElementById('draw-tools-toggle');
  var drawTools = document.getElementById('draw-tools');
  if (drawToolsToggle && drawTools) {
    drawToolsToggle.addEventListener('click', function() {
      drawTools.classList.toggle('draw-tools-open');
    });
  }
  var colorInput = document.getElementById('draw-color-input');
  var colorSwatches = document.querySelectorAll('.color-swatch');
  function onColorChange(c) {
    drawColor = c;
    if (colorInput) colorInput.value = c;
    if (selectedIndex != null && drawings[selectedIndex]) {
      drawings[selectedIndex].color = c;
      if (typeof renderDrawings === 'function') renderDrawings();
    }
  }
  if (colorInput) colorInput.addEventListener('input', function() { onColorChange(this.value); });
  for (var si = 0; si < colorSwatches.length; si++) {
    (function(sw) {
      sw.addEventListener('click', function() {
        var c = this.getAttribute('data-color');
        if (c) {
          onColorChange(c);
          for (var sj = 0; sj < colorSwatches.length; sj++) colorSwatches[sj].classList.remove('active');
          this.classList.add('active');
        }
      });
    })(colorSwatches[si]);
  }

  // =============================================
  //  DRAWING TOOLS — canvas overlay system
  // =============================================
  var drawCanvas = document.getElementById('draw-overlay');
  var drawCtx = drawCanvas ? drawCanvas.getContext('2d') : null;
  var drawings = [];       // saved drawings: { type, points (in price/time coords), color }
  var activeTool = 'cursor';
  var drawState = null;    // in-progress drawing { type, startTime, startPrice, ... }
  var selectedIndex = null;
  var dragState = null;    // { index, startPx, startPy, startT1, startP1, startT2, startP2 } for move

  function resizeDrawCanvas() {
    if (!drawCanvas || !drawCtx || !chartRef.chart) return;
    var container = document.getElementById('lw-chart-container');
    var rect = container.getBoundingClientRect();
    var dpr = window.devicePixelRatio || 1;
    drawCanvas.width = rect.width * dpr;
    drawCanvas.height = rect.height * dpr;
    drawCanvas.style.width = rect.width + 'px';
    drawCanvas.style.height = rect.height + 'px';
    drawCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
    renderDrawings();
  }

  // Convert price/time to pixel coordinates
  function toPixel(time, price) {
    if (!chartRef.chart || !chartRef.series) return null;
    var x = chartRef.chart.timeScale().timeToCoordinate(time);
    var y = chartRef.series.priceToCoordinate(price);
    if (x === null || y === null || x === undefined || y === undefined) return null;
    return { x: x, y: y };
  }

  // Convert pixel to price/time (clamp to canvas so long trend lines complete at edges)
  function fromPixel(x, y) {
    if (!chartRef.chart || !chartRef.series) return null;
    var time = chartRef.chart.timeScale().coordinateToTime(x);
    var price = chartRef.series.coordinateToPrice(y);
    if (time == null || price == null) return null;
    return { time: time, price: price };
  }
  function fromPixelClamped(px, py, canvasW, canvasH) {
    var w = canvasW || (drawCanvas ? drawCanvas.getBoundingClientRect().width : 0);
    var h = canvasH || (drawCanvas ? drawCanvas.getBoundingClientRect().height : 0);
    var x = Math.max(0, Math.min(w, px));
    var y = Math.max(0, Math.min(h, py));
    return fromPixel(x, y);
  }

  // Hit test: distance from point to line segment (px, py in pixel coords)
  function distToSegment(px, py, x1, y1, x2, y2) {
    var dx = x2 - x1, dy = y2 - y1;
    var len = Math.sqrt(dx * dx + dy * dy) || 1e-6;
    var t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / (len * len)));
    var nx = x1 + t * dx, ny = y1 + t * dy;
    return Math.sqrt((px - nx) * (px - nx) + (py - ny) * (py - ny));
  }
  function hitTestDrawing(px, py, d, idx) {
    var w = drawCanvas ? drawCanvas.getBoundingClientRect().width : 0;
    var h = drawCanvas ? drawCanvas.getBoundingClientRect().height : 0;
    var hitRadius = 10;
    if (d.type === 'hline') {
      var yPx = chartRef.series.priceToCoordinate(d.price);
      if (yPx == null) return false;
      return Math.abs(py - yPx) <= hitRadius && px >= 0 && px <= w;
    }
    if (d.type === 'trendline') {
      var p1 = toPixel(d.t1, d.p1);
      var p2 = toPixel(d.t2, d.p2);
      if (!p1 || !p2) return false;
      return distToSegment(px, py, p1.x, p1.y, p2.x, p2.y) <= hitRadius;
    }
    if (d.type === 'ray') {
      var rp1 = toPixel(d.t1, d.p1);
      var rp2 = toPixel(d.t2, d.p2);
      if (!rp1 || !rp2) return false;
      var dx = rp2.x - rp1.x, dy = rp2.y - rp1.y;
      var extX = rp2.x + dx * 50, extY = rp2.y + dy * 50;
      return distToSegment(px, py, rp1.x, rp1.y, extX, extY) <= hitRadius && (px - rp1.x) * dx + (py - rp1.y) * dy >= -5;
    }
    if (d.type === 'rect') {
      var rc1 = toPixel(d.t1, d.p1);
      var rc2 = toPixel(d.t2, d.p2);
      if (!rc1 || !rc2) return false;
      var rx = Math.min(rc1.x, rc2.x), ry = Math.min(rc1.y, rc2.y);
      var rw = Math.abs(rc2.x - rc1.x), rh = Math.abs(rc2.y - rc1.y);
      return px >= rx - hitRadius && px <= rx + rw + hitRadius && py >= ry - hitRadius && py <= ry + rh + hitRadius;
    }
    if (d.type === 'fibdraw') {
      var fc1 = toPixel(d.t1, d.p1);
      var fc2 = toPixel(d.t2, d.p2);
      if (!fc1 || !fc2) return false;
      return distToSegment(px, py, fc1.x, fc1.y, fc2.x, fc2.y) <= hitRadius;
    }
    return false;
  }
  // Which drawing is under (px, py)? Top-most first (last in array).
  function getDrawingAt(px, py) {
    for (var i = drawings.length - 1; i >= 0; i--) {
      if (hitTestDrawing(px, py, drawings[i], i)) return i;
    }
    return -1;
  }

  function renderDrawings(tempDraw) {
    if (!drawCtx || !drawCanvas) return;
    var w = drawCanvas.width / (window.devicePixelRatio || 1);
    var h = drawCanvas.height / (window.devicePixelRatio || 1);
    drawCtx.clearRect(0, 0, w, h);

    var all = drawings.slice();
    if (tempDraw) all.push(tempDraw);

    for (var i = 0; i < all.length; i++) {
      var d = all[i];
      var isSelected = (selectedIndex === i && !tempDraw);
      drawCtx.strokeStyle = d.color || '#f59e0b';
      drawCtx.lineWidth = (d.lineWidth || 1.5) + (isSelected ? 2 : 0);
      drawCtx.setLineDash(d.dash || []);
      drawCtx.fillStyle = d.fill || 'transparent';
      drawCtx.font = '10px monospace';

      if (d.type === 'hline') {
        var yPx = chartRef.series.priceToCoordinate(d.price);
        if (yPx == null) continue;
        drawCtx.beginPath();
        drawCtx.moveTo(0, yPx);
        drawCtx.lineTo(w, yPx);
        drawCtx.stroke();
        // Price label
        drawCtx.fillStyle = d.color || '#f59e0b';
        var lbl = d.price >= 1 ? d.price.toFixed(2) : d.price.toFixed(6);
        drawCtx.fillText(lbl, 4, yPx - 4);
        drawCtx.fillStyle = 'transparent';

      } else if (d.type === 'trendline') {
        var p1 = toPixel(d.t1, d.p1);
        var p2 = toPixel(d.t2, d.p2);
        if (!p1 || !p2) continue;
        drawCtx.beginPath();
        drawCtx.moveTo(p1.x, p1.y);
        drawCtx.lineTo(p2.x, p2.y);
        drawCtx.stroke();
        // Small anchor dots
        drawCtx.fillStyle = d.color || '#f59e0b';
        drawCtx.beginPath(); drawCtx.arc(p1.x, p1.y, 3, 0, Math.PI * 2); drawCtx.fill();
        drawCtx.beginPath(); drawCtx.arc(p2.x, p2.y, 3, 0, Math.PI * 2); drawCtx.fill();
        drawCtx.fillStyle = 'transparent';

      } else if (d.type === 'ray') {
        var rp1 = toPixel(d.t1, d.p1);
        var rp2 = toPixel(d.t2, d.p2);
        if (!rp1 || !rp2) continue;
        var dx = rp2.x - rp1.x;
        var dy = rp2.y - rp1.y;
        var extX = rp2.x + dx * 50;
        var extY = rp2.y + dy * 50;
        drawCtx.beginPath();
        drawCtx.moveTo(rp1.x, rp1.y);
        drawCtx.lineTo(extX, extY);
        drawCtx.stroke();
        drawCtx.fillStyle = d.color || '#f59e0b';
        drawCtx.beginPath(); drawCtx.arc(rp1.x, rp1.y, 3, 0, Math.PI * 2); drawCtx.fill();
        drawCtx.fillStyle = 'transparent';

      } else if (d.type === 'rect') {
        var rc1 = toPixel(d.t1, d.p1);
        var rc2 = toPixel(d.t2, d.p2);
        if (!rc1 || !rc2) continue;
        var rx = Math.min(rc1.x, rc2.x);
        var ry = Math.min(rc1.y, rc2.y);
        var rw = Math.abs(rc2.x - rc1.x);
        var rh = Math.abs(rc2.y - rc1.y);
        drawCtx.fillStyle = (d.color || '#f59e0b') + '18';
        drawCtx.fillRect(rx, ry, rw, rh);
        drawCtx.strokeRect(rx, ry, rw, rh);
        drawCtx.fillStyle = 'transparent';

      } else if (d.type === 'fibdraw') {
        var highPrice = Math.max(d.p1, d.p2);
        var lowPrice = Math.min(d.p1, d.p2);
        var range = highPrice - lowPrice;
        var fibRatios = [
          { r: 0, label: '0%', color: '#6b7280' },
          { r: 0.236, label: '23.6%', color: '#a78bfa' },
          { r: 0.382, label: '38.2%', color: '#a78bfa' },
          { r: 0.5,   label: '50%',   color: '#c084fc' },
          { r: 0.618, label: '61.8%', color: '#e879f9' },
          { r: 0.786, label: '78.6%', color: '#f472b6' },
          { r: 1,     label: '100%',  color: '#6b7280' }
        ];
        for (var fi = 0; fi < fibRatios.length; fi++) {
          var fib = fibRatios[fi];
          var fibPrice = highPrice - range * fib.r;
          var fibY = chartRef.series.priceToCoordinate(fibPrice);
          if (fibY == null) continue;
          drawCtx.strokeStyle = fib.color;
          drawCtx.setLineDash([4, 4]);
          drawCtx.lineWidth = 1;
          drawCtx.beginPath();
          drawCtx.moveTo(0, fibY);
          drawCtx.lineTo(w, fibY);
          drawCtx.stroke();
          // Label
          drawCtx.fillStyle = fib.color;
          var fibLbl = fib.label + ' – ' + (fibPrice >= 1 ? fibPrice.toFixed(2) : fibPrice.toFixed(6));
          drawCtx.fillText(fibLbl, 4, fibY - 4);
        }
        // Shaded zone between 0.5 and 0.618
        var y50 = chartRef.series.priceToCoordinate(highPrice - range * 0.5);
        var y618 = chartRef.series.priceToCoordinate(highPrice - range * 0.618);
        if (y50 != null && y618 != null) {
          drawCtx.fillStyle = 'rgba(192,132,252,0.08)';
          drawCtx.fillRect(0, Math.min(y50, y618), w, Math.abs(y618 - y50));
        }
        drawCtx.setLineDash([]);
        drawCtx.fillStyle = 'transparent';
        drawCtx.strokeStyle = d.color || '#f59e0b';
        drawCtx.lineWidth = 1.5;
      }
    }
    drawCtx.setLineDash([]);
  }

  // Re-render drawings whenever chart pans/zooms
  function hookChartRedraw() {
    if (!chartRef.chart) return;
    chartRef.chart.timeScale().subscribeVisibleLogicalRangeChange(function() { renderDrawings(); });
    chartRef.chart.subscribeCrosshairMove(function() { /* lightweight redraw on move if drawing */ });
  }

  function updateDeleteButton() {
    var btn = document.getElementById('draw-delete-btn');
    if (btn) {
      btn.disabled = selectedIndex == null;
      btn.style.opacity = selectedIndex != null ? '1' : '0.5';
      btn.style.cursor = selectedIndex != null ? 'pointer' : 'not-allowed';
    }
  }

  // Tool button clicks (wrapped so chart load is never blocked)
  var toolBtns = [];
  toolBtns = document.querySelectorAll('#draw-tools .tool-btn');
  for (var ti = 0; ti < toolBtns.length; ti++) {
    toolBtns[ti].addEventListener('click', function() {
      var tool = this.getAttribute('data-tool');
      if (tool === 'clear') {
        if (drawings.length === 0) return;
        if (!confirm('Clear all ' + drawings.length + ' drawing(s)?')) return;
        drawings = [];
        drawState = null;
        selectedIndex = null;
        dragState = null;
        if (drawCanvas) drawCanvas.style.pointerEvents = 'none';
        renderDrawings();
        updateDeleteButton();
        return;
      }
      if (tool === 'delete') {
        if (selectedIndex != null && drawings[selectedIndex]) {
          drawings.splice(selectedIndex, 1);
          selectedIndex = null;
          dragState = null;
          if (drawCanvas && drawings.length === 0) drawCanvas.style.pointerEvents = 'none';
          renderDrawings();
          updateDeleteButton();
        }
        return;
      }
      activeTool = tool;
      drawState = null;
      dragState = null;
      if (tool === 'cursor') selectedIndex = null;
      for (var tj = 0; tj < toolBtns.length; tj++) toolBtns[tj].classList.remove('tool-active');
      this.classList.add('tool-active');
      if (drawCanvas) {
        if (tool === 'cursor') {
          // Cursor/select mode: overlay captures clicks so user can select drawings,
          // but mousedown handler passes through if no drawing is hit
          drawCanvas.style.pointerEvents = drawings.length > 0 ? 'auto' : 'none';
          drawCanvas.style.cursor = 'default';
        } else {
          // Drawing tool active: overlay captures mouse events
          drawCanvas.style.pointerEvents = 'auto';
          drawCanvas.style.cursor = 'crosshair';
        }
      }
      renderDrawings();
      updateDeleteButton();
    });
  }

  // Get pointer coords from mouse or touch (for mobile press-and-drag)
  function getPointerCoords(e) {
    var t = (e.touches && e.touches.length > 0) ? e.touches[0] : (e.changedTouches && e.changedTouches.length > 0) ? e.changedTouches[0] : e;
    return { clientX: t.clientX, clientY: t.clientY };
  }
  function handlePointerDown(e) {
    var coords = getPointerCoords(e);
    var rect = drawCanvas.getBoundingClientRect();
    var x = coords.clientX - rect.left;
    var y = coords.clientY - rect.top;
      var w = rect.width;
      var h = rect.height;

      if (activeTool === 'cursor') {
        var idx = getDrawingAt(x, y);
        if (idx >= 0) {
          // Hit a drawing → select it and start drag
          selectedIndex = idx;
          var d = drawings[idx];
          if (d.type === 'hline') {
            dragState = { index: idx, startPx: x, startPy: y, origP1: d.price };
          } else {
            dragState = { index: idx, startPx: x, startPy: y, origT1: d.t1, origP1: d.p1, origT2: d.t2, origP2: d.p2 };
          }
          renderDrawings();
          updateDeleteButton();
        } else {
          // Missed all drawings → deselect and let chart handle the click
          selectedIndex = null;
          dragState = null;
          renderDrawings();
          updateDeleteButton();
          // Pass through to chart: temporarily disable overlay so chart gets mousedown
          if (drawCanvas) drawCanvas.style.pointerEvents = 'none';
          // Re-enable after a tick so future clicks can still select drawings
          setTimeout(function() {
            if (activeTool === 'cursor' && drawCanvas && drawings.length > 0) {
              drawCanvas.style.pointerEvents = 'auto';
            }
          }, 300);
        }
        return;
      }

      var coord = fromPixelClamped(x, y, w, h);
      if (!coord) return;

      if (activeTool === 'hline') {
        drawings.push({ type: 'hline', price: coord.price, color: drawColor, lineWidth: 1.5 });
        // Auto-switch back to cursor after placing hline
        activeTool = 'cursor';
        selectedIndex = drawings.length - 1;
        if (drawCanvas) {
          drawCanvas.style.pointerEvents = drawings.length > 0 ? 'auto' : 'none';
          drawCanvas.style.cursor = 'default';
        }
        for (var th = 0; th < toolBtns.length; th++) {
          toolBtns[th].classList.remove('tool-active');
          if (toolBtns[th].getAttribute('data-tool') === 'cursor') toolBtns[th].classList.add('tool-active');
        }
        renderDrawings();
        updateDeleteButton();
        return;
      }

      drawState = { type: activeTool, t1: coord.time, p1: coord.price };
  }
  if (drawCanvas) {
  drawCanvas.addEventListener('mousedown', handlePointerDown);
  drawCanvas.addEventListener('touchstart', function(e) {
    if (activeTool !== 'cursor' || drawings.length > 0) e.preventDefault();
    handlePointerDown(e);
  }, { passive: false });

  function handlePointerMove(e) {
      var coords = getPointerCoords(e);
      var rect = drawCanvas.getBoundingClientRect();
      var x = coords.clientX - rect.left;
      var y = coords.clientY - rect.top;
      var w = rect.width;
      var h = rect.height;

      if (dragState !== null) {
        var now = fromPixel(x, y);
        var start = fromPixel(dragState.startPx, dragState.startPy);
        if (now && start) {
          var dt = now.time - start.time;
          var dp = now.price - start.price;
          var d = drawings[dragState.index];
          if (d.type === 'hline') {
            d.price = dragState.origP1 + dp;
          } else {
            d.t1 = dragState.origT1 + dt;
            d.p1 = dragState.origP1 + dp;
            d.t2 = dragState.origT2 + dt;
            d.p2 = dragState.origP2 + dp;
          }
          dragState.startPx = x;
          dragState.startPy = y;
          dragState.origP1 = d.type === 'hline' ? d.price : d.p1;
          if (d.type !== 'hline') {
            dragState.origT1 = d.t1;
            dragState.origP1 = d.p1;
            dragState.origT2 = d.t2;
            dragState.origP2 = d.p2;
          }
        }
        renderDrawings();
        return;
      }

      if (drawState) {
        var coord = fromPixelClamped(x, y, w, h);
        if (!coord) { renderDrawings(); return; }
        var temp = Object.assign({}, drawState, { t2: coord.time, p2: coord.price, color: drawColor, lineWidth: 1.5 });
        renderDrawings(temp);
      }
    }
    drawCanvas.addEventListener('mousemove', handlePointerMove);
    drawCanvas.addEventListener('touchmove', function(e) {
      if (dragState || drawState) e.preventDefault();
      handlePointerMove(e);
    }, { passive: false });

    function handlePointerUp(e) {
      var coords = getPointerCoords(e);
      var rect = drawCanvas.getBoundingClientRect();
      var x = coords.clientX - rect.left;
      var y = coords.clientY - rect.top;
      var w = rect.width;
      var h = rect.height;
      if (dragState !== null) {
        dragState = null;
        return;
      }
      if (!drawState) return;
      var coord = fromPixelClamped(x, y, w, h);
      if (!coord) { drawState = null; renderDrawings(); return; }

      var d = Object.assign({}, drawState, { t2: coord.time, p2: coord.price, color: drawColor, lineWidth: 1.5 });
      drawings.push(d);
      drawState = null;

      // Auto-switch back to cursor mode after placing a drawing (like TradingView)
      activeTool = 'cursor';
      selectedIndex = drawings.length - 1; // select the just-drawn item
      if (drawCanvas) {
        drawCanvas.style.pointerEvents = drawings.length > 0 ? 'auto' : 'none';
        drawCanvas.style.cursor = 'default';
      }
      for (var tb = 0; tb < toolBtns.length; tb++) {
        toolBtns[tb].classList.remove('tool-active');
        if (toolBtns[tb].getAttribute('data-tool') === 'cursor') toolBtns[tb].classList.add('tool-active');
      }
      renderDrawings();
      updateDeleteButton();
    }
    drawCanvas.addEventListener('mouseup', handlePointerUp);
    drawCanvas.addEventListener('touchend', function(e) {
      if (dragState || drawState) e.preventDefault();
      handlePointerUp(e);
    }, { passive: false });
    drawCanvas.addEventListener('touchcancel', function(e) {
      if (dragState || drawState) e.preventDefault();
      drawState = null;
      dragState = null;
      renderDrawings();
    }, { passive: false });
  }
  } catch (drawErr) {
    console.warn('Drawing tools init:', drawErr);
  }
  document.addEventListener('keydown', function(e) {
    if (e.key === 'Delete' || e.key === 'Backspace') {
      if (selectedIndex != null && drawings[selectedIndex]) {
        e.preventDefault();
        drawings.splice(selectedIndex, 1);
        selectedIndex = null;
        dragState = null;
        if (drawCanvas && drawings.length === 0) drawCanvas.style.pointerEvents = 'none';
        renderDrawings();
        updateDeleteButton();
      }
      return;
    }
    if (e.key === 'Escape') {
      drawState = null;
      dragState = null;
      selectedIndex = null;
      renderDrawings();
      activeTool = 'cursor';
      if (drawCanvas) {
        drawCanvas.style.pointerEvents = 'none';
        drawCanvas.style.cursor = 'default';
      }
      for (var tk = 0; tk < toolBtns.length; tk++) {
        toolBtns[tk].classList.remove('tool-active');
        if (toolBtns[tk].getAttribute('data-tool') === 'cursor') toolBtns[tk].classList.add('tool-active');
      }
      updateDeleteButton();
    }
  });
  updateDeleteButton();

  window.addEventListener('resize', function() { resizeDrawCanvas(); });

})();
</script>

<%- include('partials/footer') %>
