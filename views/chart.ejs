<%- include('partials/header') %>
<input type="hidden" id="chart-csrf" value="<%= typeof csrfToken !== 'undefined' ? csrfToken : '' %>">

<main class="chart-page">
  <div class="chart-header">
    <% if (typeof chartCoins !== 'undefined' && chartCoins && chartCoins.length > 0) { %>
    <div class="chart-symbol-search" style="display:flex;align-items:center;gap:8px;">
      <label style="font-size:12px;color:#9ca3af;">Symbol:</label>
      <select id="chart-symbol-select" onchange="var v=this.value;if(v)location.href='/chart/'+v;" style="padding:6px 10px;background:#1e293b;border:1px solid #334155;border-radius:6px;color:#e5e7eb;font-size:13px;min-width:140px;cursor:pointer;">
        <% chartCoins.forEach(function(c) { %>
        <option value="<%= c.id %>" <%= c.id === coinId ? 'selected' : '' %>><%= c.symbol %> – <%= c.name %></option>
        <% }); %>
      </select>
    </div>
    <% } else if (typeof prevCoinId !== 'undefined' && prevCoinId) { %>
    <a href="/chart/<%= prevCoinId %>" class="btn btn-outline btn-sm chart-nav-btn" title="Previous coin">&#x2190; Prev</a>
    <% } %>
    <h1><%= coinName %> (<%= symbol %>) – Chart</h1>
    <% if (typeof chartCoins === 'undefined' || !chartCoins || chartCoins.length === 0) { %>
    <% if (typeof nextCoinId !== 'undefined' && nextCoinId) { %>
    <a href="/chart/<%= nextCoinId %>" class="btn btn-outline btn-sm chart-nav-btn" title="Next coin">Next &#x2192;</a>
    <% } %>
    <% } %>
    <a href="/trades" class="btn btn-outline btn-sm">Active Trades</a>
    <a href="/coin/<%= coinId %>" class="btn btn-outline btn-sm">Back to <%= coinName %></a>
    <% if (typeof user !== 'undefined' && user) { %><a href="/alerts" class="btn btn-outline btn-sm" style="border-color:#a78bfa;color:#a78bfa;">Alerts</a><% } %>
  </div>

  <% if (entry != null || sl != null || tp1 != null || tp2 != null || tp3 != null) { %>
  <div class="trade-levels-overlay">
    <div class="trade-levels-header">
      <div class="trade-levels-title">Trade Levels – drawn on chart</div>
      <% if (typeof tradeId !== 'undefined' && tradeId) { %>
      <label class="toggle-label live-modify-wrap">
        <input type="checkbox" id="live-modify-trades" title="Enable drag to modify SL, TP1, TP2, TP3">
        <span class="toggle-text">Live modify trades</span>
      </label>
      <span id="trade-levels-saved" style="display:none;font-size:11px;color:#10b981;margin-left:8px;">Saved</span>
      <% } %>
    </div>
    <div class="trade-levels-grid">
      <% if (tp3 != null) { %><div class="level-row tp"><span class="level-name">TP3</span><span class="level-price">$<%= tp3.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 6 }) %></span></div><% } %>
      <% if (tp2 != null) { %><div class="level-row tp"><span class="level-name">TP2</span><span class="level-price">$<%= tp2.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 6 }) %></span></div><% } %>
      <% if (tp1 != null) { %><div class="level-row tp"><span class="level-name">TP1</span><span class="level-price">$<%= tp1.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 6 }) %></span></div><% } %>
      <% if (entry != null) { %><div class="level-row entry"><span class="level-name">Entry</span><span class="level-price">$<%= entry.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 6 }) %></span></div><% } %>
      <% if (sl != null) { %>
        <div class="level-row sl">
          <span class="level-name">SL</span>
          <span class="level-price">$<%= sl.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 6 }) %></span>
          <% if (typeof originalSl !== 'undefined' && originalSl != null && originalSl !== sl) { %>
            <span class="level-original">(orig: <s>$<%= originalSl.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 6 }) %></s>)</span>
          <% } %>
        </div>
      <% } %>
    </div>
    <div class="chart-actions-bar" id="chart-actions-bar"<%= (typeof tradeActions === 'undefined' || !tradeActions || tradeActions.length === 0) ? ' style="display:none;"' : '' %>>
      <% if (typeof tradeActions !== 'undefined' && tradeActions && tradeActions.length > 0) {
        var latestByType = {};
        tradeActions.forEach(function(a) { if (a.type) latestByType[a.type] = a; });
        var deduped = Object.values(latestByType);
        deduped.forEach(function(a) { %>
          <%
            var chartDisplayVal = '';
            if (['BE','TS','LOCK'].indexOf(a.type) >= 0 && a.newValue != null) {
              chartDisplayVal = ' $' + (typeof formatPrice !== 'undefined' ? formatPrice(a.newValue) : a.newValue);
            } else if (['EXIT','PP','RP'].indexOf(a.type) >= 0 && a.marketPrice != null) {
              chartDisplayVal = ' @$' + (typeof formatPrice !== 'undefined' ? formatPrice(a.marketPrice) : a.marketPrice);
            }
          %>
          <span class="action-badge action-<%= (a.type || '').toLowerCase() %>" title="<%= a.description || '' %>"><%= (a.type || '?') + chartDisplayVal %> <%= a.timestamp ? new Date(a.timestamp).toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'}) : '' %></span>
        <% }); %>
      <% } %>
    </div>
  </div>
  <% } %>

  <!-- TradingView-style layout: tools sidebar left, chart center, timeframes bottom -->
  <div class="chart-layout">
    <!-- Left sidebar: drawing tools -->
    <aside class="chart-tools-sidebar" id="chart-tools-sidebar">
      <div class="sidebar-label">Drawing</div>
      <div class="draw-tools draw-tools-vertical" id="draw-tools">
        <button class="tool-btn tool-active" data-tool="cursor" title="Select">
          <svg width="18" height="18" viewBox="0 0 16 16" fill="currentColor"><path d="M3 1l10 6.5L8.5 9l-2 5.5L3 1z"/></svg>
        </button>
        <button class="tool-btn" data-tool="trendline" title="Trend Line">
          <svg width="18" height="18" viewBox="0 0 16 16" stroke="currentColor" stroke-width="2"><line x1="2" y1="13" x2="14" y2="3"/></svg>
        </button>
        <button class="tool-btn" data-tool="hline" title="Horizontal Line">
          <svg width="18" height="18" viewBox="0 0 16 16" stroke="currentColor" stroke-width="2"><line x1="1" y1="8" x2="15" y2="8"/></svg>
        </button>
        <button class="tool-btn" data-tool="rect" title="Rectangle">
          <svg width="18" height="18" viewBox="0 0 16 16" stroke="currentColor" stroke-width="1.5" fill="none"><rect x="2" y="3" width="12" height="10" rx="1"/></svg>
        </button>
        <button class="tool-btn" data-tool="fibdraw" title="Fibonacci">
          <svg width="18" height="18" viewBox="0 0 16 16" stroke="currentColor" fill="none" stroke-width="1.2"><line x1="1" y1="3" x2="15" y2="3" stroke-dasharray="2,2"/><line x1="1" y1="6.5" x2="15" y2="6.5" stroke-dasharray="2,2"/><line x1="1" y1="10" x2="15" y2="10" stroke-dasharray="2,2"/><line x1="1" y1="13" x2="15" y2="13" stroke-dasharray="2,2"/></svg>
        </button>
        <button class="tool-btn" data-tool="ray" title="Ray">
          <svg width="18" height="18" viewBox="0 0 16 16" stroke="currentColor" stroke-width="2"><line x1="2" y1="12" x2="14" y2="5"/><polygon points="14,5 10,5.5 12.5,7.5" fill="currentColor" stroke="none"/></svg>
        </button>
        <div class="toolbar-divider-horiz"></div>
        <div class="draw-color-picker draw-color-picker-vertical" id="draw-color-picker" title="Line color">
          <input type="color" id="draw-color-input" value="#f59e0b" title="Pick color">
          <span class="draw-color-swatches" id="draw-color-swatches">
            <span class="color-swatch" data-color="#f59e0b" style="background:#f59e0b"></span>
            <span class="color-swatch" data-color="#3b82f6" style="background:#3b82f6"></span>
            <span class="color-swatch" data-color="#22c55e" style="background:#22c55e"></span>
            <span class="color-swatch" data-color="#ef4444" style="background:#ef4444"></span>
            <span class="color-swatch" data-color="#a78bfa" style="background:#a78bfa"></span>
            <span class="color-swatch" data-color="#06b6d4" style="background:#06b6d4"></span>
          </span>
        </div>
        <div class="toolbar-divider-horiz"></div>
        <button class="tool-btn tool-btn-danger" data-tool="delete" id="draw-delete-btn" title="Delete" disabled style="opacity:0.5;cursor:not-allowed;">
          <svg width="18" height="18" viewBox="0 0 16 16" stroke="currentColor" stroke-width="2" fill="none"><path d="M3 4h10v10H3zM6 4V2h4v2M6 7v4M10 7v4"/></svg>
        </button>
        <button class="tool-btn tool-btn-danger" data-tool="clear" title="Clear all">
          <svg width="18" height="18" viewBox="0 0 16 16" stroke="currentColor" stroke-width="2" fill="none"><line x1="4" y1="4" x2="12" y2="12"/><line x1="12" y1="4" x2="4" y2="12"/></svg>
        </button>
      </div>
    </aside>

    <!-- Main chart area -->
    <div class="chart-main">
      <!-- Top bar: Fit + dropdowns across -->
      <div class="chart-top-bar">
        <button type="button" class="tool-btn chart-fit-btn" id="chart-fit-btn" title="Reset zoom / Fit content">
          <svg width="18" height="18" viewBox="0 0 16 16" stroke="currentColor" stroke-width="2" fill="none"><rect x="2" y="2" width="6" height="6" rx="1"/><rect x="8" y="8" width="6" height="6" rx="1"/></svg>
          <span class="chart-fit-text">Fit</span>
        </button>
        <div class="indicators-dropdown-wrap" id="dropdown-overlays-wrap">
          <button type="button" class="tool-btn indicators-dropdown-btn" data-dropdown="overlays" title="Overlays">Overlays <svg class="dropdown-chevron" width="12" height="12" viewBox="0 0 12 12"><path d="M2 4 L6 8 L10 4" stroke="currentColor" stroke-width="2" fill="none"/></svg></button>
          <div class="indicators-dropdown-panel">
            <label class="toggle-label"><input type="checkbox" id="toggle-bb"> <span class="toggle-text">Bollinger Bands</span></label>
            <label class="toggle-label"><input type="checkbox" id="toggle-ma"> <span class="toggle-text">Moving Averages</span></label>
            <label class="toggle-label"><input type="checkbox" id="toggle-keltner"> <span class="toggle-text">Keltner Channel</span></label>
            <label class="toggle-label"><input type="checkbox" id="toggle-donchian"> <span class="toggle-text">Donchian Channel</span></label>
            <label class="toggle-label"><input type="checkbox" id="toggle-fib"> <span class="toggle-text">Fibonacci</span></label>
          </div>
        </div>
        <div class="indicators-dropdown-wrap" id="dropdown-levels-wrap">
          <button type="button" class="tool-btn indicators-dropdown-btn" data-dropdown="levels" title="Levels">Levels <svg class="dropdown-chevron" width="12" height="12" viewBox="0 0 12 12"><path d="M2 4 L6 8 L10 4" stroke="currentColor" stroke-width="2" fill="none"/></svg></button>
          <div class="indicators-dropdown-panel">
            <label class="toggle-label"><input type="checkbox" id="toggle-sr"> <span class="toggle-text">Support / Resistance</span></label>
            <label class="toggle-label"><input type="checkbox" id="toggle-poc"> <span class="toggle-text">POC (Volume)</span></label>
            <label class="toggle-label"><input type="checkbox" id="toggle-pivots"> <span class="toggle-text">Pivot Points</span></label>
          </div>
        </div>
        <div class="indicators-dropdown-wrap" id="dropdown-patterns-wrap">
          <button type="button" class="tool-btn indicators-dropdown-btn" data-dropdown="patterns" title="Patterns">Patterns <svg class="dropdown-chevron" width="12" height="12" viewBox="0 0 12 12"><path d="M2 4 L6 8 L10 4" stroke="currentColor" stroke-width="2" fill="none"/></svg></button>
          <div class="indicators-dropdown-panel">
            <label class="toggle-label"><input type="checkbox" id="toggle-chart-patterns"> <span class="toggle-text">Chart Patterns</span></label>
            <label class="toggle-label"><input type="checkbox" id="toggle-badges"> <span class="toggle-text">Action Badges</span></label>
            <label class="toggle-label"><input type="checkbox" id="toggle-patterns"> <span class="toggle-text">Candlestick Patterns</span></label>
            <% if (typeof tradeId !== 'undefined' && tradeId) { %>
            <label class="toggle-label"><input type="checkbox" id="toggle-trade" checked> <span class="toggle-text">Trade Levels</span></label>
            <% } %>
          </div>
        </div>
        <div class="indicators-dropdown-wrap" id="dropdown-advanced-wrap">
          <button type="button" class="tool-btn indicators-dropdown-btn" data-dropdown="advanced" title="Advanced">Advanced <svg class="dropdown-chevron" width="12" height="12" viewBox="0 0 12 12"><path d="M2 4 L6 8 L10 4" stroke="currentColor" stroke-width="2" fill="none"/></svg></button>
          <div class="indicators-dropdown-panel">
            <label class="toggle-label"><input type="checkbox" id="toggle-ob"> <span class="toggle-text">Order Blocks</span></label>
            <label class="toggle-label"><input type="checkbox" id="toggle-fvg"> <span class="toggle-text">Fair Value Gaps</span></label>
            <label class="toggle-label"><input type="checkbox" id="toggle-liq"> <span class="toggle-text">Liquidity Clusters</span></label>
            <label class="toggle-label"><input type="checkbox" id="toggle-vwap"> <span class="toggle-text">VWAP</span></label>
            <label class="toggle-label"><input type="checkbox" id="toggle-premium"> <span class="toggle-text">Premium/Discount</span></label>
            <label class="toggle-label"><input type="checkbox" id="toggle-swing"> <span class="toggle-text">Swing Points</span></label>
            <label class="toggle-label"><input type="checkbox" id="toggle-structure"> <span class="toggle-text">Market Structure</span></label>
            <label class="toggle-label"><input type="checkbox" id="toggle-sessions"> <span class="toggle-text">Session Markers (Asian/London/NY)</span></label>
            <label class="toggle-label"><input type="checkbox" id="toggle-gaps"> <span class="toggle-text">Gap Markers</span></label>
            <label class="toggle-label"><input type="checkbox" id="toggle-vp"> <span class="toggle-text">Volume Profile</span></label>
          </div>
        </div>
        <div class="indicators-dropdown-wrap" id="dropdown-style-wrap">
          <button type="button" class="tool-btn indicators-dropdown-btn" data-dropdown="style" title="Style">Style <svg class="dropdown-chevron" width="12" height="12" viewBox="0 0 12 12"><path d="M2 4 L6 8 L10 4" stroke="currentColor" stroke-width="2" fill="none"/></svg></button>
          <div class="indicators-dropdown-panel">
            <div style="margin-bottom:10px;padding-bottom:10px;border-bottom:1px solid #334155;">
              <button type="button" class="btn btn-outline btn-sm" id="indicators-save-btn" style="padding:4px 10px;font-size:11px;width:100%;" title="Save current indicator toggles">Save Indicators</button>
            </div>
            <div class="candle-colors-wrap">
              <button type="button" class="tool-btn" id="candle-colors-btn" title="Candle colors">
                <svg width="18" height="18" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="4" width="4" height="8" rx="0.5"/><rect x="6" y="2" width="4" height="12" rx="0.5"/><rect x="10" y="6" width="4" height="6" rx="0.5"/></svg>
                <span>Candle colors</span>
              </button>
              <div class="candle-colors-panel" id="candle-colors-panel" style="display:none;position:absolute;top:100%;left:0;margin-top:6px;padding:10px 12px;background:rgba(15,23,42,0.98);border:1px solid #334155;border-radius:8px;z-index:100;min-width:180px;">
                <div style="font-size:11px;color:#6b7280;margin-bottom:8px;text-transform:uppercase;">Candle colors</div>
                <div style="display:flex;gap:12px;align-items:center;margin-bottom:8px;">
                  <label style="font-size:12px;color:#9ca3af;">Up</label>
                  <input type="color" id="candle-up-color" value="#22c55e" style="width:36px;height:28px;padding:2px;border:1px solid #334155;border-radius:6px;cursor:pointer;background:#1e293b;">
                </div>
                <div style="display:flex;gap:12px;align-items:center;margin-bottom:10px;">
                  <label style="font-size:12px;color:#9ca3af;">Down</label>
                  <input type="color" id="candle-down-color" value="#ef4444" style="width:36px;height:28px;padding:2px;border:1px solid #334155;border-radius:6px;cursor:pointer;background:#1e293b;">
                </div>
                <div style="display:flex;gap:6px;">
                  <button type="button" class="btn btn-outline btn-sm" id="candle-colors-save" style="padding:4px 10px;font-size:11px;">Save</button>
                  <button type="button" class="btn btn-outline btn-sm" id="candle-colors-reset" style="padding:4px 10px;font-size:11px;">Reset</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

  <!-- Lightweight Charts (primary – with trade level lines) -->
  <div class="chart-container" id="lw-chart-container" style="display:none;">
    <div id="lw-chart" style="width:100%;height:100%;"></div>
    <div class="chart-symbol-overlay" id="chart-symbol-overlay" style="position:absolute;top:8px;left:12px;z-index:6;pointer-events:none;padding:6px 10px;background:rgba(15,23,42,0.85);border:1px solid #334155;border-radius:6px;">
      <div class="chart-symbol-name" style="font-size:12px;font-weight:700;color:#e5e7eb;"><%= symbol %></div>
      <div class="chart-symbol-price" id="chart-symbol-price" style="font-size:14px;font-weight:700;color:#22c55e;font-variant-numeric:tabular-nums;">—</div>
      <div class="chart-symbol-change" id="chart-symbol-change" style="font-size:11px;color:#6b7280;">—</div>
    </div>
    <div class="chart-crosshair-info" id="chart-crosshair-info" style="display:none;position:absolute;top:8px;left:50%;transform:translateX(-50%);z-index:7;pointer-events:none;padding:6px 10px;background:rgba(15,23,42,0.85);border:1px solid #334155;border-radius:6px;font-size:11px;font-variant-numeric:tabular-nums;">
      <div style="color:#6b7280;margin-bottom:2px;"><span id="crosshair-time">—</span></div>
      <div style="display:flex;gap:12px;"><span>O <span id="crosshair-o">—</span></span><span>H <span id="crosshair-h">—</span></span><span>L <span id="crosshair-l">—</span></span><span>C <span id="crosshair-c">—</span></span></div>
    </div>
    <div class="candle-countdown-wrap" style="position:absolute;top:8px;right:12px;z-index:6;text-align:right;pointer-events:none;padding:6px 10px;background:rgba(15,23,42,0.85);border:1px solid #334155;border-radius:6px;">
      <div class="candle-countdown-label" style="font-size:10px;color:#6b7280;margin-bottom:2px;text-transform:uppercase;letter-spacing:0.5px;">Candle closes in</div>
      <div id="candle-countdown" style="font-size:14px;font-weight:700;color:#e5e7eb;font-variant-numeric:tabular-nums;"></div>
    </div>
    <div id="chart-structure-overlay" style="display:none;position:absolute;bottom:8px;left:12px;z-index:6;pointer-events:none;padding:4px 8px;background:rgba(15,23,42,0.85);border:1px solid #334155;border-radius:6px;font-size:11px;font-weight:600;color:#a78bfa;">—</div>
    <canvas id="indicator-zones-canvas" style="position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:4;"></canvas>
    <canvas id="draw-overlay" style="position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:5;"></canvas>
  </div>

  <!-- TradingView widget (fallback – always works) -->
  <div class="chart-container" id="tv-chart-container">
    <div id="tv-loading" style="display:flex;align-items:center;justify-content:center;height:100%;color:#6b7280;font-size:14px;">Loading chart...</div>
    <div class="tradingview-widget-container" id="tv-widget-wrap" style="width:100%;height:100%;display:none;">
      <div id="tradingview_widget" style="width:100%;height:100%;"></div>
    </div>
  </div>

  <!-- Timeframes bar (TradingView-style at bottom) -->
  <div class="chart-tf-bar" id="chart-tf-bar">
    <div class="tf-selector" id="tf-selector">
      <button class="tf-btn" data-tf="15m">15m</button>
      <button class="tf-btn tf-active" data-tf="1h">1H</button>
      <button class="tf-btn" data-tf="4h">4H</button>
      <button class="tf-btn" data-tf="1d">1D</button>
      <button class="tf-btn" data-tf="1w">1W</button>
    </div>
  </div>
    </div><!-- .chart-main -->
  </div><!-- .chart-layout -->

  <!-- Chart Pattern Info Panel (populated via JS) -->
  <div class="chart-pattern-panel" id="chart-pattern-panel" style="display:none;">
    <div class="chart-pattern-panel-title">Chart Patterns Detected</div>
    <div class="chart-pattern-panel-list" id="chart-pattern-list"></div>
  </div>

  <% if (tradeId) { %>
  <div class="chart-marker-legend">
    <span style="color:#6b7280;font-weight:600;">Chart Markers:</span>
    <span class="legend-item"><span class="legend-dot" style="background:#10b981;"></span> BE (Breakeven)</span>
    <span class="legend-item"><span class="legend-dot" style="background:#3b82f6;"></span> TS (Trailing Stop)</span>
    <span class="legend-item"><span class="legend-dot" style="background:#38bdf8;"></span> LOCK (Profit Lock)</span>
    <span class="legend-item"><span class="legend-dot" style="background:#f87171;"></span> EXIT</span>
    <span class="legend-item"><span class="legend-dot" style="background:#a78bfa;"></span> PP (Partial Profit)</span>
    <span class="legend-item"><span class="legend-dot" style="background:#fbbf24;"></span> RP (Reduce Position)</span>
  </div>
  <% } %>
</main>

<style>
.chart-page { padding: 1rem; max-width: 100%; box-sizing: border-box; }
.chart-header { display: flex; align-items: center; justify-content: flex-start; flex-wrap: wrap; gap: 0.75rem; margin-bottom: 1rem; }
.chart-header h1 { margin: 0; font-size: 1.25rem; color: #e5e7eb; }
.trade-levels-overlay { margin-bottom: 1rem; padding: 0.75rem 1rem; background: rgba(15,23,42,0.6); border: 1px solid #334155; border-radius: 8px; backdrop-filter: blur(8px); }
.trade-levels-header { display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 0.5rem; margin-bottom: 0.5rem; }
.trade-levels-title { font-size: 11px; color: #6b7280; text-transform: uppercase; letter-spacing: 0.5px; margin: 0; }
.trade-levels-grid { display: flex; flex-wrap: wrap; gap: 0.5rem 1rem; }
.level-row { font-size: 0.9rem; padding: 0.2rem 0.5rem; border-radius: 4px; }
.level-row.entry { background: rgba(59, 130, 246, 0.25); color: #93c5fd; }
.level-row.sl { background: rgba(239, 68, 68, 0.25); color: #fca5a5; }
.level-row.tp { background: rgba(34, 197, 94, 0.25); color: #86efac; }
.level-original { font-size: 11px; color: #6b7280; margin-left: 6px; }
.chart-actions-bar { display: flex; gap: 6px; flex-wrap: wrap; margin-top: 8px; }
.chart-actions-bar .action-badge { font-size: 10px; padding: 3px 8px; border-radius: 4px; font-weight: 600; }
.chart-actions-bar .action-badge.action-be { background: #064e3b; color: #10b981; }
.chart-actions-bar .action-badge.action-ts { background: #1e3a5f; color: #3b82f6; }
.chart-actions-bar .action-badge.action-lock { background: #0c4a6e; color: #38bdf8; }
.chart-actions-bar .action-badge.action-exit { background: #450a0a; color: #f87171; }
.chart-actions-bar .action-badge.action-pp { background: #2e1065; color: #a78bfa; }
.chart-actions-bar .action-badge.action-rp { background: #422006; color: #fbbf24; }
.chart-pattern-panel { margin-top: 8px; padding: 10px 14px; background: rgba(15,23,42,0.92); border: 1px solid #334155; border-radius: 8px; backdrop-filter: blur(8px); }
.chart-pattern-panel-title { font-size: 11px; color: #6b7280; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 8px; font-weight: 600; }
.chart-pattern-panel-list { display: flex; gap: 8px; flex-wrap: wrap; }
.chart-pattern-card { padding: 8px 12px; border-radius: 6px; font-size: 12px; min-width: 200px; max-width: 350px; }
.chart-pattern-card.bull { background: rgba(34,197,94,0.1); border-left: 3px solid #22c55e; }
.chart-pattern-card.bear { background: rgba(239,68,68,0.1); border-left: 3px solid #ef4444; }
.chart-pattern-card.neutral { background: rgba(234,179,8,0.1); border-left: 3px solid #eab308; }
.chart-pattern-card .cp-name { font-weight: 700; font-size: 13px; }
.chart-pattern-card .cp-meta { color: #9ca3af; font-size: 11px; margin-top: 3px; }
.chart-pattern-card .cp-target { color: #6b7280; font-size: 11px; margin-top: 2px; }
.chart-pattern-card .cp-wr { font-size: 10px; padding: 2px 6px; border-radius: 3px; font-weight: 600; display: inline-block; margin-top: 4px; }
.chart-pattern-card.bull .cp-wr { background: rgba(34,197,94,0.2); color: #22c55e; }
.chart-pattern-card.bear .cp-wr { background: rgba(239,68,68,0.2); color: #ef4444; }
.chart-pattern-card.neutral .cp-wr { background: rgba(234,179,8,0.2); color: #eab308; }
.chart-marker-legend { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 6px; padding: 6px 10px; background: rgba(15,23,42,0.8); border: 1px solid #1e293b; border-radius: 6px; font-size: 10px; color: #9ca3af; }
.chart-marker-legend .legend-item { display: flex; align-items: center; gap: 4px; }
.chart-marker-legend .legend-dot { width: 8px; height: 8px; border-radius: 50%; }
/* TradingView-style layout */
.chart-layout { display: flex; gap: 0; margin-bottom: 8px; background: rgba(15,23,42,0.6); border: 1px solid #334155; border-radius: 8px; overflow: hidden; backdrop-filter: blur(8px); }
.chart-tools-sidebar { display: flex; flex-direction: column; width: 52px; min-width: 52px; padding: 8px 6px; background: rgba(15,23,42,0.85); border-right: 1px solid #334155; }
.sidebar-label { font-size: 9px; color: #6b7280; text-transform: uppercase; letter-spacing: 0.5px; padding: 4px 0 6px; text-align: center; }
.draw-tools-vertical { display: flex; flex-direction: column; gap: 4px; align-items: center; }
.draw-tools-vertical .tool-btn { width: 36px; height: 36px; min-width: 36px; min-height: 36px; padding: 6px; }
.toolbar-divider-horiz { height: 1px; width: 100%; background: #334155; margin: 6px 0; }
.draw-color-picker-vertical { flex-direction: column; }
.draw-color-picker-vertical .draw-color-swatches { display: flex; flex-wrap: wrap; justify-content: center; gap: 4px; }
.chart-main { flex: 1; display: flex; flex-direction: column; min-width: 0; }
.chart-top-bar { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; padding: 6px 10px; background: rgba(15,23,42,0.5); border-bottom: 1px solid #334155; }
.indicators-dropdown-wrap { position: relative; }
.indicators-dropdown-btn { display: flex; align-items: center; gap: 6px; padding: 6px 12px; }
.indicators-dropdown-btn .dropdown-chevron { margin-left: 2px; transition: transform 0.2s; }
.indicators-dropdown-wrap.open .dropdown-chevron { transform: rotate(180deg); }
.indicators-dropdown-panel { display: none; position: absolute; top: 100%; left: 0; margin-top: 4px; padding: 12px 14px; min-width: 220px; background: rgba(15,23,42,0.98); border: 1px solid #334155; border-radius: 8px; z-index: 100; box-shadow: 0 8px 24px rgba(0,0,0,0.4); }
.indicators-dropdown-wrap.open .indicators-dropdown-panel { display: flex; flex-direction: column; gap: 8px; }
.indicators-dropdown-title { font-size: 10px; color: #6b7280; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 2px; }
.chart-tf-bar { display: flex; align-items: center; justify-content: center; padding: 8px 12px; background: rgba(15,23,42,0.6); border-top: 1px solid #334155; }
.chart-container { position: relative; width: 100%; flex: 1; height: calc(100vh - 380px); min-height: 380px; overflow: hidden; background: #0f172a; }
.tf-selector { display: flex; gap: 4px; }
.tf-btn { background: rgba(30,41,59,0.8); border: 1px solid #334155; color: #9ca3af; padding: 6px 14px; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.15s; }
.tf-btn:hover { background: rgba(51,65,85,0.8); color: #e5e7eb; }
.tf-btn.tf-active { background: rgba(59,130,246,0.25); border-color: #3b82f6; color: #93c5fd; }
.chart-fit-btn { display: flex; align-items: center; gap: 4px; padding: 6px 10px; }
.chart-fit-text { font-size: 12px; font-weight: 600; }
.tool-btn { background: rgba(30,41,59,0.8); border: 1px solid #334155; color: #9ca3af; padding: 6px 8px; border-radius: 6px; cursor: pointer; transition: all 0.15s; display: flex; align-items: center; justify-content: center; min-width: 38px; min-height: 38px; }
.tool-btn:hover { background: rgba(51,65,85,0.8); color: #e5e7eb; }
.tool-btn.tool-active { background: rgba(59,130,246,0.25); border-color: #3b82f6; color: #93c5fd; }
.tool-btn-danger:hover { background: rgba(239,68,68,0.25); border-color: #ef4444; color: #fca5a5; }
.draw-color-picker { display: flex; align-items: center; gap: 6px; position: relative; }
.draw-color-picker input[type="color"] { width: 28px; height: 28px; padding: 2px; border: 1px solid #334155; border-radius: 6px; cursor: pointer; background: #1e293b; }
.draw-color-swatches { display: flex; gap: 4px; }
.color-swatch { width: 20px; height: 20px; border-radius: 4px; cursor: pointer; border: 2px solid transparent; }
.color-swatch:hover, .color-swatch.active { border-color: #fff; }
.toggle-label { display: flex; align-items: center; gap: 6px; cursor: pointer; font-size: 12px; color: #9ca3af; user-select: none; }
.toggle-label input[type="checkbox"] { accent-color: #3b82f6; width: 14px; height: 14px; cursor: pointer; }
.toggle-label:hover .toggle-text { color: #e5e7eb; }
.candle-colors-wrap { position: relative; }
/* Mobile: collapse sidebar, stack layout */
@media (max-width: 768px) {
  .chart-page { padding: 0.5rem; }
  .chart-header h1 { font-size: 1.1rem; }
  .chart-layout { flex-direction: column; }
  .chart-tools-sidebar { flex-direction: row; width: 100%; min-width: 100%; padding: 8px; border-right: none; border-bottom: 1px solid #334155; }
  .sidebar-label { display: none; }
  .draw-tools-vertical { flex-direction: row; flex-wrap: wrap; justify-content: center; gap: 6px; }
  .draw-tools-vertical .tool-btn { min-width: 44px; min-height: 44px; }
  .draw-color-picker-vertical { flex-direction: row; }
  .draw-color-picker-vertical .draw-color-swatches { justify-content: flex-start; }
  .chart-container { min-height: 300px; height: calc(100vh - 420px); min-height: max(300px, 45vh); }
  .chart-tf-bar { padding: 10px; }
  .tf-btn { padding: 10px 16px; min-height: 44px; font-size: 14px; }
}
</style>

<!-- Try Lightweight Charts first (draws price level lines on chart) -->
<script src="https://cdn.jsdelivr.net/npm/lightweight-charts@4.2.0/dist/lightweight-charts.standalone.production.js"></script>

<script>
(function() {
  var coinId = '<%= coinId %>';
  var tvSymbol = '<%= tvSymbol %>';
  var levels = {
    entry: <%- JSON.stringify(entry) %>,
    sl: <%- JSON.stringify(sl) %>,
    originalSl: <%- JSON.stringify(typeof originalSl !== 'undefined' ? originalSl : null) %>,
    tp1: <%- JSON.stringify(tp1) %>,
    tp2: <%- JSON.stringify(tp2) %>,
    tp3: <%- JSON.stringify(tp3) %>
  };
  var tradeId = <%- JSON.stringify(typeof tradeId !== 'undefined' ? tradeId : null) %>;
  var tradeDirection = <%- JSON.stringify(typeof direction !== 'undefined' ? direction : null) %>;
  var initialActions = <%- JSON.stringify(typeof tradeActions !== 'undefined' ? tradeActions : []) %>;
  var chartRef = { chart: null, series: null, volumeSeries: null, slLine: null, origSlLine: null, priceLines: [], fibLines: [], srLines: [], pocLines: [], bbSeries: [], tradeLevelMap: {}, candleTimes: [], candleData: [] };
  var CANDLE_STORAGE_KEY_UP = 'chartCandleUpColor';
  var CANDLE_STORAGE_KEY_DOWN = 'chartCandleDownColor';
  var CANDLE_DEFAULT_UP = '#22c55e';
  var CANDLE_DEFAULT_DOWN = '#ef4444';
  function getCandleColors() {
    try {
      var up = localStorage.getItem(CANDLE_STORAGE_KEY_UP) || CANDLE_DEFAULT_UP;
      var down = localStorage.getItem(CANDLE_STORAGE_KEY_DOWN) || CANDLE_DEFAULT_DOWN;
      return { up: up, down: down };
    } catch (e) { return { up: CANDLE_DEFAULT_UP, down: CANDLE_DEFAULT_DOWN }; }
  }
  function applyCandleColors(up, down) {
    if (!chartRef.series) return;
    try {
      chartRef.series.applyOptions({
        upColor: up, downColor: down,
        borderUpColor: up, borderDownColor: down,
        wickUpColor: up, wickDownColor: down
      });
    } catch (e) { console.warn('applyCandleColors:', e); }
  }
  var currentTF = '1h';
  var CHART_INDICATOR_STORAGE_KEY = 'chartIndicatorPrefs';
  function getIndicatorDefaults() {
    var hasTrade = !!(tradeId && (levels.entry != null || levels.sl != null));
    return {
      bb: false, ma: false, keltner: false, donchian: false, fib: false,
      badges: false, patterns: false, chartPatterns: false, sr: false, poc: false, pivots: false,
      tradeLevels: hasTrade, ob: false, fvg: false, liq: false, vwap: false, premium: false, swing: false, structure: false,
      sessions: false, gaps: false, vp: false
    };
  }
  function loadIndicatorPrefs() {
    try {
      var raw = localStorage.getItem(CHART_INDICATOR_STORAGE_KEY);
      if (raw) {
        var prefs = JSON.parse(raw);
        return Object.assign(getIndicatorDefaults(), prefs);
      }
    } catch (e) {}
    return getIndicatorDefaults();
  }
  var indicatorPrefs = loadIndicatorPrefs();
  var showBB = indicatorPrefs.bb;
  var showMA = indicatorPrefs.ma;
  var showKeltner = indicatorPrefs.keltner;
  var showDonchian = indicatorPrefs.donchian;
  var showFib = indicatorPrefs.fib;
  var showBadges = indicatorPrefs.badges;
  var showPatterns = indicatorPrefs.patterns;
  var showChartPatterns = indicatorPrefs.chartPatterns;
  var showSR = indicatorPrefs.sr;
  var showPOC = indicatorPrefs.poc;
  var showPivots = indicatorPrefs.pivots;
  var showTradeLevels = indicatorPrefs.tradeLevels;
  var showOB = indicatorPrefs.ob;
  var showFVG = indicatorPrefs.fvg;
  var showLiq = indicatorPrefs.liq;
  var showVWAP = indicatorPrefs.vwap;
  var showPremium = indicatorPrefs.premium;
  var showSwing = indicatorPrefs.swing;
  var showStructure = indicatorPrefs.structure;
  var showSessions = indicatorPrefs.sessions;
  var showGaps = indicatorPrefs.gaps;
  var showVP = indicatorPrefs.vp;
  var srLevels = { support: null, resistance: null };
  var pocLevel = null;
  var lastPatterns = [];
  var lastChartPatterns = [];
  var lastOrderBlocks = [];
  var lastFVGs = [];
  var lastLiquidityClusters = {};
  var lastVWAP = null;
  var lastSwingPoints = { swingLows: [], swingHighs: [] };
  var lastMarketStructure = null;
  var lastPivotPoints = null;
  var lastVolumeProfile = null;
  var chartRefMASeries = [];
  var chartRefKeltnerSeries = [];
  var chartRefDonchianSeries = [];
  var chartRefOBLines = [];
  var chartRefFVGLines = [];
  var chartRefLiqLines = [];
  var chartRefVWAPLine = null;
  var chartRefPremiumLines = [];
  var chartRefPivotLines = [];
  var chartPatternSeries = [];  // line series for chart pattern trendlines
  var drawColor = '#f59e0b';

  // Action marker colors and shapes for Lightweight Charts
  var actionMarkerConfig = {
    BE:   { color: '#10b981', shape: 'arrowUp',   position: 'belowBar', label: 'BE' },
    TS:   { color: '#3b82f6', shape: 'arrowUp',   position: 'belowBar', label: 'TS' },
    LOCK: { color: '#38bdf8', shape: 'arrowUp',   position: 'belowBar', label: 'LOCK' },
    EXIT: { color: '#f87171', shape: 'arrowDown', position: 'aboveBar', label: 'EXIT' },
    PP:   { color: '#a78bfa', shape: 'arrowDown', position: 'aboveBar', label: 'PP' },
    RP:   { color: '#fbbf24', shape: 'arrowDown', position: 'aboveBar', label: 'RP' }
  };

  // Snap an action timestamp to the nearest candle time
  function snapToCandle(actionTimeMs) {
    if (!chartRef.candleTimes || chartRef.candleTimes.length === 0) return null;
    var actionSec = Math.floor(actionTimeMs / 1000);
    var best = chartRef.candleTimes[0];
    var bestDiff = Math.abs(actionSec - best);
    for (var i = 1; i < chartRef.candleTimes.length; i++) {
      var diff = Math.abs(actionSec - chartRef.candleTimes[i]);
      if (diff < bestDiff) { best = chartRef.candleTimes[i]; bestDiff = diff; }
    }
    return best;
  }

  // Build and apply chart markers from actions array
  // Only shows the MOST RECENT action of each type to keep the chart clean.
  // e.g. if stop was trailed 5 times, only the latest TS marker is shown.
  function applyActionMarkers(actions) {
    if (!chartRef.series) return;

    var markers = [];

    // Add action badge markers (if badges enabled and actions exist)
    if (showBadges && actions && actions.length > 0) {
      // Deduplicate: keep only the latest action of each type
      var latestByType = {};
      for (var i = 0; i < actions.length; i++) {
        var a = actions[i];
        if (!a.type || !a.timestamp) continue;
        // Always overwrite — actions array is chronological so last one wins
        latestByType[a.type] = a;
      }
      var deduped = Object.keys(latestByType).map(function(k) { return latestByType[k]; });

      for (var j = 0; j < deduped.length; j++) {
        var act = deduped[j];
        var cfg = actionMarkerConfig[act.type];
        if (!cfg) continue;
        var ts = snapToCandle(new Date(act.timestamp).getTime());
        if (ts == null) continue;
        var priceInfo = '';
        if (['BE','TS','LOCK'].indexOf(act.type) >= 0 && act.newValue != null) {
          priceInfo = ' $' + (act.newValue >= 1 ? act.newValue.toFixed(2) : act.newValue.toFixed(6));
        } else if (['EXIT','PP','RP'].indexOf(act.type) >= 0 && act.marketPrice != null) {
          priceInfo = ' @$' + (act.marketPrice >= 1 ? act.marketPrice.toFixed(2) : act.marketPrice.toFixed(6));
        }
        markers.push({
          time: ts,
          position: cfg.position,
          color: cfg.color,
          shape: cfg.shape,
          text: cfg.label + priceInfo
        });
      }
    }

    // Add pattern markers if enabled (independent of action badges)
    if (showPatterns && lastPatterns && lastPatterns.length > 0) {
      for (var p = 0; p < lastPatterns.length; p++) {
        var pat = lastPatterns[p];
        if (!pat.time) continue;
        var isBull = pat.direction === 'BULL';
        var isBear = pat.direction === 'BEAR';
        markers.push({
          time: pat.time,
          position: isBull ? 'belowBar' : isBear ? 'aboveBar' : 'inBar',
          color: isBull ? '#10b981' : isBear ? '#ef4444' : '#6b7280',
          shape: isBull ? 'arrowUp' : isBear ? 'arrowDown' : 'circle',
          text: pat.name
        });
      }
    }

    // Add swing point markers if enabled
    if (showSwing && lastSwingPoints) {
      var swl = lastSwingPoints.swingLows || [];
      var swh = lastSwingPoints.swingHighs || [];
      for (var si = 0; si < swl.length; si++) {
        if (swl[si].time) markers.push({ time: swl[si].time, position: 'belowBar', color: '#22c55e', shape: 'circle', text: 'L' });
      }
      for (var si = 0; si < swh.length; si++) {
        if (swh[si].time) markers.push({ time: swh[si].time, position: 'aboveBar', color: '#ef4444', shape: 'circle', text: 'H' });
      }
    }

    // Sort by time (required by Lightweight Charts) and apply
    if (markers.length > 0) {
      markers.sort(function(a, b) { return a.time - b.time; });
    }
    try { chartRef.series.setMarkers(markers); } catch(e) { console.warn('setMarkers error:', e); }
  }

  var lwContainer = document.getElementById('lw-chart-container');
  var tvContainer = document.getElementById('tv-chart-container');
  var tfSelector = document.getElementById('tf-selector');

  // TradingView interval map for timeframe selector
  var tvIntervalMap = { '15m': '15', '1h': '60', '4h': '240', '1d': 'D', '1w': 'W' };
  var tfIntervalSec = { '15m': 900, '1h': 3600, '4h': 14400, '1d': 86400, '1w': 604800 };
  var tfLabel = { '15m': '15m', '1h': '1H', '4h': '4H', '1d': '1D', '1w': '1W' };
  var countdownIntervalId = null;

  function updateCandleCountdown() {
    var el = document.getElementById('candle-countdown');
    var labelEl = document.querySelector('.candle-countdown-label');
    if (!el || !chartRef.candleTimes || chartRef.candleTimes.length === 0) return;
    var lastTime = chartRef.candleTimes[chartRef.candleTimes.length - 1];
    var intervalSec = tfIntervalSec[currentTF] || 3600;
    var nextCandleSec = lastTime + intervalSec;
    var nowSec = Math.floor(Date.now() / 1000);
    var remaining = nextCandleSec - nowSec;
    if (remaining <= 0) {
      el.textContent = '00:00';
      if (labelEl) labelEl.textContent = 'Next ' + (tfLabel[currentTF] || currentTF) + ' candle';
      return;
    }
    var m = Math.floor(remaining / 60);
    var s = remaining % 60;
    el.textContent = (m < 10 ? '0' : '') + m + ':' + (s < 10 ? '0' : '') + s;
    if (labelEl) labelEl.textContent = 'Candle closes in';
  }

  function startCandleCountdown() {
    if (countdownIntervalId) clearInterval(countdownIntervalId);
    updateCandleCountdown();
    countdownIntervalId = setInterval(updateCandleCountdown, 1000);
  }

  function stopCandleCountdown() {
    if (countdownIntervalId) { clearInterval(countdownIntervalId); countdownIntervalId = null; }
    var el = document.getElementById('candle-countdown');
    var labelEl = document.querySelector('.candle-countdown-label');
    if (el) el.textContent = '';
    if (labelEl) labelEl.textContent = '';
  }

  var lastCandleData = null;
  var candleAnimationIntervalId = null;

  function updateLastCandleWithPrice(price) {
    if (!chartRef.series || !lastCandleData || !chartRef.chart) return;
    var nowSec = Math.floor(Date.now() / 1000);
    var intervalSec = tfIntervalSec[currentTF] || 3600;
    var nextCandleSec = lastCandleData.time + intervalSec;
    if (nowSec >= nextCandleSec) {
      loadCandles(currentTF, { preserveView: true });
      return;
    }
    var high = Math.max(lastCandleData.high, price);
    var low = Math.min(lastCandleData.low, price);
    var bar = { time: lastCandleData.time, open: lastCandleData.open, high: high, low: low, close: price };
    lastCandleData = bar;
    try { chartRef.series.update(bar); } catch(e) {}
  }

  function startCandleAnimation() {
    if (candleAnimationIntervalId) clearInterval(candleAnimationIntervalId);
    candleAnimationIntervalId = setInterval(function() {
      if (!chartRef.chart || !chartRef.series || tvFallbackAttempted) return;
      fetch('/api/prices', { credentials: 'same-origin' })
        .then(function(r) { return r.ok ? r.json() : null; })
        .then(function(result) {
          if (!result || !result.success || !result.data) return;
          var p = result.data.find(function(x) { return x.id === coinId; });
          if (p && p.price != null) {
            updateLastCandleWithPrice(Number(p.price));
            updateSymbolOverlay(Number(p.price), p.change24h);
          }
        })
        .catch(function() {});
    }, 6000);
  }

  function stopCandleAnimation() {
    if (candleAnimationIntervalId) { clearInterval(candleAnimationIntervalId); candleAnimationIntervalId = null; }
  }

  function updateSymbolOverlay(price, change24h) {
    var priceEl = document.getElementById('chart-symbol-price');
    var changeEl = document.getElementById('chart-symbol-change');
    if (!priceEl) return;
    if (price != null && Number.isFinite(price)) {
      priceEl.textContent = '$' + (price >= 1 ? price.toFixed(2) : price.toFixed(6));
      priceEl.style.color = (change24h != null && change24h >= 0) ? '#22c55e' : '#ef4444';
    }
    if (changeEl && change24h != null && Number.isFinite(change24h)) {
      var sign = change24h >= 0 ? '+' : '';
      changeEl.textContent = sign + change24h.toFixed(2) + '%';
      changeEl.style.color = change24h >= 0 ? '#22c55e' : '#ef4444';
    }
  }

  function setupCrosshairInfo(chart) {
    var infoEl = document.getElementById('chart-crosshair-info');
    var timeEl = document.getElementById('crosshair-time');
    var oEl = document.getElementById('crosshair-o');
    var hEl = document.getElementById('crosshair-h');
    var lEl = document.getElementById('crosshair-l');
    var cEl = document.getElementById('crosshair-c');
    if (!infoEl || !chart) return;
    function fmt(p) { return p >= 1 ? p.toFixed(2) : p.toFixed(6); }
    function findCandle(time) {
      if (!chartRef.candleData || chartRef.candleData.length === 0) return null;
      var best = chartRef.candleData[0];
      var bestDiff = Math.abs(time - best.time);
      for (var i = 1; i < chartRef.candleData.length; i++) {
        var d = Math.abs(time - chartRef.candleData[i].time);
        if (d < bestDiff) { best = chartRef.candleData[i]; bestDiff = d; }
      }
      return best;
    }
    chart.subscribeCrosshairMove(function(param) {
      if (!param.time || !param.point) {
        infoEl.style.display = 'none';
        return;
      }
      var candle = findCandle(param.time);
      if (candle) {
        if (timeEl) timeEl.textContent = new Date(candle.time * 1000).toLocaleString([], { dateStyle: 'short', timeStyle: 'short' });
        if (oEl) oEl.textContent = fmt(candle.open);
        if (hEl) hEl.textContent = fmt(candle.high);
        if (lEl) lEl.textContent = fmt(candle.low);
        if (cEl) cEl.textContent = fmt(candle.close);
        infoEl.style.display = '';
      } else {
        infoEl.style.display = 'none';
      }
    });
    var chartEl = document.getElementById('lw-chart');
    if (chartEl) {
      chartEl.addEventListener('mouseleave', function() { infoEl.style.display = 'none'; });
    }
  }

  // ---- Fallback: show TradingView widget ----
  var tvFallbackAttempted = false;
  function showTradingViewFallback() {
    if (tvFallbackAttempted) return; // prevent double-loading
    tvFallbackAttempted = true;
    stopCandleCountdown();
    stopCandleAnimation();
    lwContainer.style.display = 'none';
    tvContainer.style.display = '';
    var chartTfBar = document.getElementById('chart-tf-bar');
    if (chartTfBar) chartTfBar.style.display = 'none';
    var tvLoading = document.getElementById('tv-loading');
    var tvWrap = document.getElementById('tv-widget-wrap');
    var script = document.createElement('script');
    script.src = 'https://s3.tradingview.com/tv.js';
    script.onload = function() {
      try {
        if (tvLoading) tvLoading.style.display = 'none';
        if (tvWrap) tvWrap.style.display = '';
        new TradingView.widget({
          container_id: 'tradingview_widget',
          autosize: true,
          symbol: tvSymbol,
          interval: tvIntervalMap[currentTF] || '60',
          timezone: 'Etc/UTC',
          theme: 'dark',
          style: '1',
          locale: 'en',
          toolbar_bg: '#0f172a',
          enable_publishing: false,
          hide_side_toolbar: false,
          allow_symbol_change: true,
          save_image: false,
          show_popup_button: true,
          popup_width: '1000',
          popup_height: '650'
        });
      } catch (tvErr) {
        console.error('TradingView widget failed:', tvErr);
        if (tvLoading) { tvLoading.textContent = 'Chart unavailable. Please try refreshing the page.'; tvLoading.style.display = 'flex'; }
      }
    };
    script.onerror = function() {
      console.error('TradingView script failed to load');
      if (tvLoading) { tvLoading.textContent = 'Chart unavailable. Please try refreshing the page.'; tvLoading.style.display = 'flex'; }
    };
    document.body.appendChild(script);
  }

  // ---- Primary: Lightweight Charts with trade levels ----
  if (typeof LightweightCharts === 'undefined') {
    console.warn('Lightweight Charts not loaded, falling back to TradingView');
    showTradingViewFallback();
    return;
  }

  function addPriceLines() {
    if (!chartRef.series) return;
    if (chartRef.slLine) { try { chartRef.series.removePriceLine(chartRef.slLine); } catch(e) {} chartRef.slLine = null; }
    if (chartRef.origSlLine) { try { chartRef.series.removePriceLine(chartRef.origSlLine); } catch(e) {} chartRef.origSlLine = null; }
    chartRef.priceLines.forEach(function(pl) {
      try { chartRef.series.removePriceLine(pl); } catch(e) {}
    });
    chartRef.priceLines = [];
    chartRef.fibLines.forEach(function(pl) {
      try { chartRef.series.removePriceLine(pl); } catch(e) {}
    });
    chartRef.fibLines = [];
    chartRef.srLines.forEach(function(pl) {
      try { chartRef.series.removePriceLine(pl); } catch(e) {}
    });
    chartRef.srLines = [];
    chartRef.pocLines.forEach(function(pl) {
      try { chartRef.series.removePriceLine(pl); } catch(e) {}
    });
    chartRef.pocLines = [];
    chartRefOBLines.forEach(function(pl) { try { chartRef.series.removePriceLine(pl); } catch(e) {} });
    chartRefOBLines = [];
    chartRefFVGLines.forEach(function(pl) { try { chartRef.series.removePriceLine(pl); } catch(e) {} });
    chartRefFVGLines = [];
    chartRefLiqLines.forEach(function(pl) { try { chartRef.series.removePriceLine(pl); } catch(e) {} });
    chartRefLiqLines = [];
    if (chartRefVWAPLine) { try { chartRef.series.removePriceLine(chartRefVWAPLine); } catch(e) {} chartRefVWAPLine = null; }
    chartRefPremiumLines.forEach(function(pl) { try { chartRef.series.removePriceLine(pl); } catch(e) {} });
    chartRefPremiumLines = [];
    chartRefPivotLines.forEach(function(pl) { try { chartRef.series.removePriceLine(pl); } catch(e) {} });
    chartRefPivotLines = [];

    chartRef.tradeLevelMap = {};
    var lineOpts = { lineWidth: 2, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: true };
    if (showTradeLevels) {
      if (levels.sl != null) {
        chartRef.slLine = chartRef.series.createPriceLine(Object.assign({}, lineOpts, { price: levels.sl, color: '#ef4444', title: 'SL' }));
        chartRef.tradeLevelMap.sl = { line: chartRef.slLine, price: levels.sl };
      }
      if (levels.originalSl != null && levels.originalSl !== levels.sl) {
        chartRef.origSlLine = chartRef.series.createPriceLine(Object.assign({}, lineOpts, { price: levels.originalSl, color: '#78716c', title: 'Orig SL', lineStyle: LightweightCharts.LineStyle.Dotted }));
      }
      if (levels.entry != null) {
        chartRef.priceLines.push(chartRef.series.createPriceLine(Object.assign({}, lineOpts, { price: levels.entry, color: '#3b82f6', title: 'Entry' })));
      }
      if (levels.tp1 != null) {
        var tp1Line = chartRef.series.createPriceLine(Object.assign({}, lineOpts, { price: levels.tp1, color: '#22c55e', title: 'TP1' }));
        chartRef.priceLines.push(tp1Line);
        chartRef.tradeLevelMap.tp1 = { line: tp1Line, price: levels.tp1 };
      }
      if (levels.tp2 != null) {
        var tp2Line = chartRef.series.createPriceLine(Object.assign({}, lineOpts, { price: levels.tp2, color: '#22c55e', title: 'TP2' }));
        chartRef.priceLines.push(tp2Line);
        chartRef.tradeLevelMap.tp2 = { line: tp2Line, price: levels.tp2 };
      }
      if (levels.tp3 != null) {
        var tp3Line = chartRef.series.createPriceLine(Object.assign({}, lineOpts, { price: levels.tp3, color: '#22c55e', title: 'TP3' }));
        chartRef.priceLines.push(tp3Line);
        chartRef.tradeLevelMap.tp3 = { line: tp3Line, price: levels.tp3 };
      }
    } else {
      chartRef.slLine = null;
      chartRef.origSlLine = null;
    }
    // Fibonacci levels (dotted, subtle) — stored separately for toggling
    <% if (fibLevels) { %>
    if (showFib) {
      var fibOpts = Object.assign({}, lineOpts, { lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dotted });
      <% if (fibLevels.fib236) { %>chartRef.fibLines.push(chartRef.series.createPriceLine(Object.assign({}, fibOpts, { price: <%= fibLevels.fib236 %>, color: '#a78bfa', title: 'Fib 23.6%' })));<% } %>
      <% if (fibLevels.fib382) { %>chartRef.fibLines.push(chartRef.series.createPriceLine(Object.assign({}, fibOpts, { price: <%= fibLevels.fib382 %>, color: '#a78bfa', title: 'Fib 38.2%' })));<% } %>
      <% if (fibLevels.fib500) { %>chartRef.fibLines.push(chartRef.series.createPriceLine(Object.assign({}, fibOpts, { price: <%= fibLevels.fib500 %>, color: '#c084fc', title: 'Fib 50%' })));<% } %>
      <% if (fibLevels.fib618) { %>chartRef.fibLines.push(chartRef.series.createPriceLine(Object.assign({}, fibOpts, { price: <%= fibLevels.fib618 %>, color: '#e879f9', title: 'Fib 61.8%' })));<% } %>
    }
    <% } %>
    // Support/Resistance with role reversal (toggleable) — redrawn on timeframe switch
    if (showSR && srLevels.support != null && srLevels.resistance != null && srLevels.support !== srLevels.resistance) {
      var srOpts = Object.assign({}, lineOpts, { lineWidth: 1.5, lineStyle: LightweightCharts.LineStyle.Solid });
      chartRef.srLines.push(chartRef.series.createPriceLine(Object.assign({}, srOpts, { price: srLevels.support, color: '#22c55e', title: 'Support' })));
      chartRef.srLines.push(chartRef.series.createPriceLine(Object.assign({}, srOpts, { price: srLevels.resistance, color: '#ef4444', title: 'Resistance' })));
    }
    // POC (Point of Control) - volume profile
    if (showPOC && pocLevel != null) {
      var pocOpts = Object.assign({}, lineOpts, { lineWidth: 1.5, lineStyle: LightweightCharts.LineStyle.Dotted });
      chartRef.pocLines.push(chartRef.series.createPriceLine(Object.assign({}, pocOpts, { price: pocLevel, color: '#a78bfa', title: 'POC' })));
    }
    // Pivot Points
    if (showPivots && lastPivotPoints) {
      var ppOpts = Object.assign({}, lineOpts, { lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dotted });
      chartRefPivotLines.push(chartRef.series.createPriceLine(Object.assign({}, ppOpts, { price: lastPivotPoints.p, color: '#f59e0b', title: 'P' })));
      if (lastPivotPoints.r1 != null) chartRefPivotLines.push(chartRef.series.createPriceLine(Object.assign({}, ppOpts, { price: lastPivotPoints.r1, color: '#ef4444', title: 'R1' })));
      if (lastPivotPoints.r2 != null) chartRefPivotLines.push(chartRef.series.createPriceLine(Object.assign({}, ppOpts, { price: lastPivotPoints.r2, color: '#ef4444', title: 'R2' })));
      if (lastPivotPoints.s1 != null) chartRefPivotLines.push(chartRef.series.createPriceLine(Object.assign({}, ppOpts, { price: lastPivotPoints.s1, color: '#22c55e', title: 'S1' })));
      if (lastPivotPoints.s2 != null) chartRefPivotLines.push(chartRef.series.createPriceLine(Object.assign({}, ppOpts, { price: lastPivotPoints.s2, color: '#22c55e', title: 'S2' })));
    }
    // Order Blocks (top + bottom lines per zone)
    if (showOB && lastOrderBlocks.length > 0) {
      var obOpts = Object.assign({}, lineOpts, { lineWidth: 1.5, lineStyle: LightweightCharts.LineStyle.Solid });
      for (var obi = 0; obi < lastOrderBlocks.length; obi++) {
        var ob = lastOrderBlocks[obi];
        var obColor = ob.type === 'BULL' ? 'rgba(34,197,94,0.8)' : 'rgba(239,68,68,0.8)';
        chartRefOBLines.push(chartRef.series.createPriceLine(Object.assign({}, obOpts, { price: ob.top, color: obColor, title: 'OB' })));
        chartRefOBLines.push(chartRef.series.createPriceLine(Object.assign({}, obOpts, { price: ob.bottom, color: obColor, title: '' })));
      }
    }
    // Fair Value Gaps
    if (showFVG && lastFVGs.length > 0) {
      var fvgOpts = Object.assign({}, lineOpts, { lineWidth: 1.5, lineStyle: LightweightCharts.LineStyle.Dashed });
      for (var fvgi = 0; fvgi < lastFVGs.length; fvgi++) {
        var fvg = lastFVGs[fvgi];
        var fvgColor = fvg.type === 'BULL' ? 'rgba(34,197,94,0.7)' : 'rgba(239,68,68,0.7)';
        chartRefFVGLines.push(chartRef.series.createPriceLine(Object.assign({}, fvgOpts, { price: fvg.top, color: fvgColor, title: 'FVG' })));
        chartRefFVGLines.push(chartRef.series.createPriceLine(Object.assign({}, fvgOpts, { price: fvg.bottom, color: fvgColor, title: '' })));
      }
    }
    // Liquidity Clusters
    if (showLiq && lastLiquidityClusters) {
      var liqOpts = Object.assign({}, lineOpts, { lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dotted });
      if (lastLiquidityClusters.above != null) chartRefLiqLines.push(chartRef.series.createPriceLine(Object.assign({}, liqOpts, { price: lastLiquidityClusters.above, color: '#06b6d4', title: 'Liq Above' })));
      if (lastLiquidityClusters.below != null) chartRefLiqLines.push(chartRef.series.createPriceLine(Object.assign({}, liqOpts, { price: lastLiquidityClusters.below, color: '#06b6d4', title: 'Liq Below' })));
    }
    // VWAP
    if (showVWAP && lastVWAP != null && lastVWAP > 0) {
      var vwapOpts = Object.assign({}, lineOpts, { lineWidth: 2, lineStyle: LightweightCharts.LineStyle.Solid });
      chartRefVWAPLine = chartRef.series.createPriceLine(Object.assign({}, vwapOpts, { price: lastVWAP, color: '#8b5cf6', title: 'VWAP' }));
    }
    // Premium/Discount (Fib 0.5 zone from swing high/low)
    if (showPremium && srLevels.support != null && srLevels.resistance != null && srLevels.support !== srLevels.resistance) {
      var mid = (srLevels.resistance + srLevels.support) / 2;
      var premOpts = Object.assign({}, lineOpts, { lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dotted });
      chartRefPremiumLines.push(chartRef.series.createPriceLine(Object.assign({}, premOpts, { price: mid, color: '#a78bfa', title: 'Equilibrium' })));
    }
    // Market Structure overlay
    var structEl = document.getElementById('chart-structure-overlay');
    if (structEl) {
      if (showStructure && lastMarketStructure && lastMarketStructure !== 'UNKNOWN') {
        structEl.style.display = '';
        structEl.textContent = 'Structure: ' + lastMarketStructure;
      } else {
        structEl.style.display = 'none';
      }
    }
    renderZoneOverlays();
  }

  function renderZoneOverlays() {
    var zonesCanvas = document.getElementById('indicator-zones-canvas');
    if (!zonesCanvas || !chartRef.chart || !chartRef.series || !chartRef.candleData || chartRef.candleData.length === 0) return;
    var ctx = zonesCanvas.getContext('2d');
    if (!ctx) return;
    var w = zonesCanvas.getBoundingClientRect().width;
    var h = zonesCanvas.getBoundingClientRect().height;
    if (w <= 0 || h <= 0) return;
    ctx.clearRect(0, 0, w, h);
    var ts = chartRef.chart.timeScale();
    var visibleRange = ts.getVisibleLogicalRange();
    if (!visibleRange) return;
    var firstTime = chartRef.candleData[0] && chartRef.candleData[0].time;
    var lastTime = chartRef.candleData[chartRef.candleData.length - 1] && chartRef.candleData[chartRef.candleData.length - 1].time;
    if (firstTime == null || lastTime == null) return;
    function toPx(time, price) {
      var x = ts.timeToCoordinate(time);
      var y = chartRef.series.priceToCoordinate(price);
      return (x != null && y != null) ? { x: x, y: y } : null;
    }
    if (showOB && lastOrderBlocks.length > 0) {
      for (var obi = 0; obi < lastOrderBlocks.length; obi++) {
        var ob = lastOrderBlocks[obi];
        var startTime = (ob.idx != null && chartRef.candleData[ob.idx]) ? chartRef.candleData[ob.idx].time : firstTime;
        var p1 = toPx(startTime, ob.top);
        var p2 = toPx(lastTime, ob.bottom);
        if (p1 && p2) {
          ctx.fillStyle = ob.type === 'BULL' ? 'rgba(34,197,94,0.2)' : 'rgba(239,68,68,0.2)';
          ctx.fillRect(p1.x, Math.min(p1.y, p2.y), Math.max(0, p2.x - p1.x), Math.abs(p2.y - p1.y));
        }
      }
    }
    if (showFVG && lastFVGs.length > 0) {
      for (var fvgi = 0; fvgi < lastFVGs.length; fvgi++) {
        var fvg = lastFVGs[fvgi];
        var startTime = (fvg.idx != null && chartRef.candleData[fvg.idx]) ? chartRef.candleData[fvg.idx].time : firstTime;
        var p1 = toPx(startTime, fvg.top);
        var p2 = toPx(lastTime, fvg.bottom);
        if (p1 && p2) {
          ctx.fillStyle = fvg.type === 'BULL' ? 'rgba(34,197,94,0.18)' : 'rgba(239,68,68,0.18)';
          ctx.fillRect(p1.x, Math.min(p1.y, p2.y), Math.max(0, p2.x - p1.x), Math.abs(p2.y - p1.y));
        }
      }
    }
    if (showSessions && chartRef.candleData.length > 1) {
      var daySec = 86400;
      var t0 = Math.floor(firstTime / daySec) * daySec;
      var t1 = Math.ceil(lastTime / daySec) * daySec;
      for (var d = t0; d <= t1; d += daySec) {
        var asianStart = d; var asianEnd = d + 8 * 3600;
        var londonStart = d + 8 * 3600; var londonEnd = d + 16 * 3600;
        var nyStart = d + 13 * 3600; var nyEnd = d + 21 * 3600;
        var drawBand = function(s, e, color) {
          var x1 = ts.timeToCoordinate(s);
          var x2 = ts.timeToCoordinate(e);
          if (x1 != null && x2 != null && x2 > 0 && x1 < w) {
            ctx.fillStyle = color;
            ctx.fillRect(Math.max(0, x1), 0, Math.min(w, x2 - x1), h);
          }
        };
        drawBand(asianStart, asianEnd, 'rgba(59,130,246,0.06)');
        drawBand(londonStart, londonEnd, 'rgba(234,179,8,0.06)');
        drawBand(nyStart, nyEnd, 'rgba(34,197,94,0.06)');
      }
    }
    if (showGaps && chartRef.candleData.length >= 2) {
      var cd = chartRef.candleData;
      for (var gi = 0; gi < cd.length - 1; gi++) {
        var c0 = cd[gi], c1 = cd[gi + 1];
        var gap = null;
        if (c1.low > c0.high * 1.001) gap = { type: 'BULL', time: c1.time, top: c1.low, bottom: c0.high };
        else if (c1.high < c0.low * 0.999) gap = { type: 'BEAR', time: c1.time, top: c0.low, bottom: c1.high };
        if (gap) {
          var pt = toPx(gap.time, (gap.top + gap.bottom) / 2);
          if (pt && pt.x >= 0 && pt.x <= w) {
            ctx.strokeStyle = gap.type === 'BULL' ? 'rgba(34,197,94,0.6)' : 'rgba(239,68,68,0.6)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(pt.x, chartRef.series.priceToCoordinate(gap.top));
            ctx.lineTo(pt.x, chartRef.series.priceToCoordinate(gap.bottom));
            ctx.stroke();
          }
        }
      }
    }
    if (showVP && lastVolumeProfile && lastVolumeProfile.buckets && lastVolumeProfile.buckets.length > 0) {
      var vpW = 60, vpPad = 8;
      var maxVol = Math.max.apply(null, lastVolumeProfile.buckets.map(function(b) { return b.volume; }));
      if (maxVol > 0) {
        for (var vi = 0; vi < lastVolumeProfile.buckets.length; vi++) {
          var b = lastVolumeProfile.buckets[vi];
          var y = chartRef.series.priceToCoordinate(b.price);
          if (y != null && y >= 0 && y <= h) {
            var barW = (b.volume / maxVol) * vpW;
            ctx.fillStyle = Math.abs(b.price - (lastVolumeProfile.poc || 0)) < 0.0001 ? 'rgba(168,85,247,0.5)' : 'rgba(107,114,128,0.35)';
            ctx.fillRect(w - vpPad - barW, y - 2, barW, 4);
          }
        }
      }
    }
  }

  function toggleSRLines(visible) {
    showSR = visible;
    if (!chartRef.series) return;
    if (!visible) {
      chartRef.srLines.forEach(function(pl) {
        try { chartRef.series.removePriceLine(pl); } catch(e) {}
      });
      chartRef.srLines = [];
    } else {
      addPriceLines();
    }
  }

  function togglePOCLines(visible) {
    showPOC = visible;
    if (!chartRef.series) return;
    if (!visible) {
      chartRef.pocLines.forEach(function(pl) {
        try { chartRef.series.removePriceLine(pl); } catch(e) {}
      });
      chartRef.pocLines = [];
    } else {
      addPriceLines();
    }
  }

  function toggleTradeLevels(visible) {
    showTradeLevels = visible;
    if (!chartRef.series) return;
    if (!visible) {
      if (chartRef.slLine) { try { chartRef.series.removePriceLine(chartRef.slLine); } catch(e) {} chartRef.slLine = null; }
      if (chartRef.origSlLine) { try { chartRef.series.removePriceLine(chartRef.origSlLine); } catch(e) {} chartRef.origSlLine = null; }
      chartRef.priceLines.forEach(function(pl) { try { chartRef.series.removePriceLine(pl); } catch(e) {} });
      chartRef.priceLines = [];
    } else {
      addPriceLines();
    }
  }

  function toggleBBLines(visible) {
    showBB = visible;
    if (!chartRef.chart) return;
    if (!visible) {
      removeBollingerBands();
    } else {
      renderBollingerBands();
    }
  }

  function toggleMALines(visible) { showMA = visible; if (!chartRef.chart) return; if (!visible) removeMALines(); else renderMALines(); }
  function toggleKeltnerLines(visible) { showKeltner = visible; if (!chartRef.chart) return; if (!visible) removeKeltnerLines(); else renderKeltnerLines(); }
  function toggleDonchianLines(visible) { showDonchian = visible; if (!chartRef.chart) return; if (!visible) removeDonchianLines(); else renderDonchianLines(); }
  function togglePivotsLines(visible) { showPivots = visible; if (!chartRef.series) return; addPriceLines(); }
  function toggleOBLines(visible) { showOB = visible; if (!chartRef.series) return; addPriceLines(); }
  function toggleFVGLines(visible) { showFVG = visible; if (!chartRef.series) return; addPriceLines(); }
  function toggleLiqLines(visible) { showLiq = visible; if (!chartRef.series) return; addPriceLines(); }
  function toggleVWAPLine(visible) { showVWAP = visible; if (!chartRef.series) return; addPriceLines(); }
  function togglePremiumLines(visible) { showPremium = visible; if (!chartRef.series) return; addPriceLines(); }
  function toggleSwingMarkers(visible) { showSwing = visible; if (!chartRef.series) return; applyActionMarkers(initialActions || []); }
  function toggleStructureOverlay(visible) { showStructure = visible; if (!chartRef.series) return; addPriceLines(); }

  // Toggle Fib lines on/off
  function toggleFibLines(visible) {
    showFib = visible;
    if (!chartRef.series) return;
    if (!visible) {
      chartRef.fibLines.forEach(function(pl) {
        try { chartRef.series.removePriceLine(pl); } catch(e) {}
      });
      chartRef.fibLines = [];
    } else {
      addPriceLines();
    }
  }

  // Toggle badge markers on/off
  function toggleBadges(visible) {
    showBadges = visible;
    if (!chartRef.series) return;
    // Re-apply markers (applyActionMarkers handles showBadges/showPatterns flags)
    applyActionMarkers(initialActions || []);
  }

  // =============================================
  //  BOLLINGER BANDS — SMA(20) ± 2*std
  // =============================================
  function removeBollingerBands() {
    for (var i = 0; i < chartRef.bbSeries.length; i++) {
      try { chartRef.chart.removeSeries(chartRef.bbSeries[i]); } catch(e) {}
    }
    chartRef.bbSeries = [];
  }

  function renderBollingerBands() {
    removeBollingerBands();
    if (!showBB || !chartRef.chart || !chartRef.candleData || chartRef.candleData.length < 20) return;
    var period = 20;
    var mult = 2;
    var closes = chartRef.candleData.map(function(c) { return c.close; });
    var upper = [], middle = [], lower = [];
    for (var i = period - 1; i < closes.length; i++) {
      var slice = closes.slice(i - period + 1, i + 1);
      var sma = slice.reduce(function(a, b) { return a + b; }, 0) / period;
      var variance = slice.reduce(function(sum, v) { return sum + (v - sma) * (v - sma); }, 0) / period;
      var std = Math.sqrt(variance) || 0;
      var t = chartRef.candleData[i].time;
      middle.push({ time: t, value: sma });
      upper.push({ time: t, value: sma + mult * std });
      lower.push({ time: t, value: sma - mult * std });
    }
    try {
      var upperSeries = chartRef.chart.addLineSeries({ color: 'rgba(168,85,247,0.8)', lineWidth: 1, crosshairMarkerVisible: true, lastValueVisible: true, priceLineVisible: false });
      var middleSeries = chartRef.chart.addLineSeries({ color: 'rgba(251,191,36,0.8)', lineWidth: 1, crosshairMarkerVisible: true, lastValueVisible: true, priceLineVisible: false });
      var lowerSeries = chartRef.chart.addLineSeries({ color: 'rgba(168,85,247,0.8)', lineWidth: 1, crosshairMarkerVisible: true, lastValueVisible: true, priceLineVisible: false });
      upperSeries.setData(upper);
      middleSeries.setData(middle);
      lowerSeries.setData(lower);
      chartRef.bbSeries = [upperSeries, middleSeries, lowerSeries];
    } catch (e) { console.warn('Bollinger Bands error:', e); }
  }

  // =============================================
  //  MOVING AVERAGES — SMA(20), EMA(9), EMA(21)
  // =============================================
  function removeMALines() {
    for (var i = 0; i < chartRefMASeries.length; i++) {
      try { chartRef.chart.removeSeries(chartRefMASeries[i]); } catch(e) {}
    }
    chartRefMASeries = [];
  }
  function renderMALines() {
    removeMALines();
    if (!showMA || !chartRef.chart || !chartRef.candleData || chartRef.candleData.length < 21) return;
    var closes = chartRef.candleData.map(function(c) { return c.close; });
    function ema(data, period) {
      var k = 2 / (period + 1);
      var result = [];
      var prev = null;
      for (var i = 0; i < data.length; i++) {
        if (i < period - 1) result.push(null);
        else {
          if (prev == null) {
            prev = data.slice(0, period).reduce(function(a, b) { return a + b; }, 0) / period;
          }
          prev = data[i] * k + prev * (1 - k);
          result.push(prev);
        }
      }
      return result;
    }
    var sma20 = [], ema9Arr = [], ema21Arr = [];
    for (var i = 19; i < closes.length; i++) {
      var t = chartRef.candleData[i].time;
      var s = closes.slice(i - 19, i + 1).reduce(function(a, b) { return a + b; }, 0) / 20;
      sma20.push({ time: t, value: s });
    }
    var e9 = ema(closes, 9);
    var e21 = ema(closes, 21);
    for (var i = 0; i < closes.length; i++) {
      if (e9[i] != null) ema9Arr.push({ time: chartRef.candleData[i].time, value: e9[i] });
      if (e21[i] != null) ema21Arr.push({ time: chartRef.candleData[i].time, value: e21[i] });
    }
    try {
      var smaSeries = chartRef.chart.addLineSeries({ color: 'rgba(251,191,36,0.9)', lineWidth: 2, crosshairMarkerVisible: true, lastValueVisible: true, priceLineVisible: false });
      var ema9Series = chartRef.chart.addLineSeries({ color: 'rgba(59,130,246,0.9)', lineWidth: 1.5, crosshairMarkerVisible: true, lastValueVisible: true, priceLineVisible: false });
      var ema21Series = chartRef.chart.addLineSeries({ color: 'rgba(168,85,247,0.9)', lineWidth: 1.5, crosshairMarkerVisible: true, lastValueVisible: true, priceLineVisible: false });
      smaSeries.setData(sma20);
      ema9Series.setData(ema9Arr);
      ema21Series.setData(ema21Arr);
      chartRefMASeries = [smaSeries, ema9Series, ema21Series];
    } catch (e) { console.warn('MA error:', e); }
  }

  // =============================================
  //  KELTNER CHANNEL — EMA(20) ± ATR(20)*2
  // =============================================
  function removeKeltnerLines() {
    for (var i = 0; i < chartRefKeltnerSeries.length; i++) {
      try { chartRef.chart.removeSeries(chartRefKeltnerSeries[i]); } catch(e) {}
    }
    chartRefKeltnerSeries = [];
  }
  function renderKeltnerLines() {
    removeKeltnerLines();
    if (!showKeltner || !chartRef.chart || !chartRef.candleData || chartRef.candleData.length < 21) return;
    var period = 20;
    var mult = 2;
    var closes = chartRef.candleData.map(function(c) { return c.close; });
    var highs = chartRef.candleData.map(function(c) { return c.high; });
    var lows = chartRef.candleData.map(function(c) { return c.low; });
    function ema(data, p) {
      var k = 2 / (p + 1);
      var out = [];
      for (var i = 0; i < data.length; i++) {
        if (i < p - 1) out.push(null);
        else {
          var prev = data.slice(i - p + 1, i + 1).reduce(function(a, b) { return a + b; }, 0) / p;
          for (var j = i - p + 1; j <= i; j++) prev = data[j] * k + prev * (1 - k);
          out.push(prev);
        }
      }
      return out;
    }
    function atr(h, l, c, p) {
      var trs = [];
      for (var i = 1; i < h.length; i++) {
        trs.push(Math.max(h[i] - l[i], Math.abs(h[i] - c[i-1]), Math.abs(l[i] - c[i-1])));
      }
      var out = [];
      for (var i = p - 1; i < trs.length; i++) {
        var avg = trs.slice(i - p + 1, i + 1).reduce(function(a, b) { return a + b; }, 0) / p;
        out.push(avg);
      }
      return out;
    }
    var emaMid = ema(closes, period);
    var atrVals = atr(highs, lows, closes, period);
    var upper = [], middle = [], lower = [];
    for (var i = period - 1; i < closes.length; i++) {
      var aidx = i - (period - 1);
      var t = chartRef.candleData[i].time;
      var m = emaMid[i];
      var a = atrVals[aidx] || 0;
      if (m != null) {
        middle.push({ time: t, value: m });
        upper.push({ time: t, value: m + mult * a });
        lower.push({ time: t, value: m - mult * a });
      }
    }
    try {
      var kcUpper = chartRef.chart.addLineSeries({ color: 'rgba(34,197,94,0.7)', lineWidth: 1, crosshairMarkerVisible: true, lastValueVisible: true, priceLineVisible: false });
      var kcMid = chartRef.chart.addLineSeries({ color: 'rgba(251,191,36,0.8)', lineWidth: 1.5, crosshairMarkerVisible: true, lastValueVisible: true, priceLineVisible: false });
      var kcLower = chartRef.chart.addLineSeries({ color: 'rgba(239,68,68,0.7)', lineWidth: 1, crosshairMarkerVisible: true, lastValueVisible: true, priceLineVisible: false });
      kcUpper.setData(upper);
      kcMid.setData(middle);
      kcLower.setData(lower);
      chartRefKeltnerSeries = [kcUpper, kcMid, kcLower];
    } catch (e) { console.warn('Keltner error:', e); }
  }

  // =============================================
  //  DONCHIAN CHANNEL — highest high / lowest low (20)
  // =============================================
  function removeDonchianLines() {
    for (var i = 0; i < chartRefDonchianSeries.length; i++) {
      try { chartRef.chart.removeSeries(chartRefDonchianSeries[i]); } catch(e) {}
    }
    chartRefDonchianSeries = [];
  }
  function renderDonchianLines() {
    removeDonchianLines();
    if (!showDonchian || !chartRef.chart || !chartRef.candleData || chartRef.candleData.length < 21) return;
    var period = 20;
    var highs = chartRef.candleData.map(function(c) { return c.high; });
    var lows = chartRef.candleData.map(function(c) { return c.low; });
    var upper = [], lower = [];
    for (var i = period - 1; i < chartRef.candleData.length; i++) {
      var sliceH = highs.slice(i - period + 1, i + 1);
      var sliceL = lows.slice(i - period + 1, i + 1);
      var t = chartRef.candleData[i].time;
      upper.push({ time: t, value: Math.max.apply(null, sliceH) });
      lower.push({ time: t, value: Math.min.apply(null, sliceL) });
    }
    try {
      var dcUpper = chartRef.chart.addLineSeries({ color: 'rgba(34,197,94,0.6)', lineWidth: 1, crosshairMarkerVisible: true, lastValueVisible: true, priceLineVisible: false });
      var dcLower = chartRef.chart.addLineSeries({ color: 'rgba(239,68,68,0.6)', lineWidth: 1, crosshairMarkerVisible: true, lastValueVisible: true, priceLineVisible: false });
      dcUpper.setData(upper);
      dcLower.setData(lower);
      chartRefDonchianSeries = [dcUpper, dcLower];
    } catch (e) { console.warn('Donchian error:', e); }
  }

  // =============================================
  //  CHART PATTERN TRENDLINES — draw/remove
  // =============================================
  function removeChartPatternLines() {
    for (var i = 0; i < chartPatternSeries.length; i++) {
      try { chartRef.chart.removeSeries(chartPatternSeries[i]); } catch(e) {}
    }
    chartPatternSeries = [];
  }

  function updateChartPatternPanel() {
    var panel = document.getElementById('chart-pattern-panel');
    var list = document.getElementById('chart-pattern-list');
    if (!panel || !list) return;
    if (!lastChartPatterns || lastChartPatterns.length === 0) {
      panel.style.display = 'none';
      return;
    }
    panel.style.display = '';
    var html = '';
    for (var i = 0; i < lastChartPatterns.length; i++) {
      var p = lastChartPatterns[i];
      var cls = p.direction === 'BULL' ? 'bull' : p.direction === 'BEAR' ? 'bear' : 'neutral';
      var dir = p.direction === 'BULL' ? 'Bullish' : p.direction === 'BEAR' ? 'Bearish' : 'Neutral';
      var targetStr = '';
      if (p.target) {
        targetStr = '<div class="cp-target">Target: $' + (p.target >= 1 ? p.target.toFixed(2) : p.target.toFixed(6)) + '</div>';
      }
      var wrStr = '';
      if (p.reliability && p.reliability.winRate) {
        wrStr = '<span class="cp-wr">' + Math.round(p.reliability.winRate * 100) + '% win rate | Tier ' + (p.reliability.tier || '?') + '</span>';
      }
      html += '<div class="chart-pattern-card ' + cls + '">' +
        '<div class="cp-name">' + p.name + '</div>' +
        '<div class="cp-meta">' + dir + ' ' + p.type + (p.completion != null ? ' | ' + p.completion + '% complete' : '') +
        (p.volumeConfirm ? ' | Vol ✓' : '') +
        (p.breakoutVolumeConfirm ? ' | Breakout vol ✓' : '') +
        (p.breakoutCloseConfirm ? ' | Close beyond ✓' : '') + '</div>' +
        targetStr + wrStr +
        '</div>';
    }
    list.innerHTML = html;
  }

  function renderChartPatterns() {
    removeChartPatternLines();
    updateChartPatternPanel();
    if (!showChartPatterns || !chartRef.chart || !lastChartPatterns || lastChartPatterns.length === 0) return;

    for (var pi = 0; pi < lastChartPatterns.length; pi++) {
      var pat = lastChartPatterns[pi];
      if (!pat.trendlines || pat.trendlines.length === 0) continue;

      var isBull = pat.direction === 'BULL';
      var isBear = pat.direction === 'BEAR';
      var lineColor = isBull ? 'rgba(34,197,94,0.7)' : isBear ? 'rgba(239,68,68,0.7)' : 'rgba(234,179,8,0.7)';

      for (var ti = 0; ti < pat.trendlines.length; ti++) {
        var tl = pat.trendlines[ti];
        if (!tl.startTime || !tl.endTime || !tl.startPrice || !tl.endPrice) continue;

        // Use line series for trendlines
        try {
          var lineSeries = chartRef.chart.addLineSeries({
            color: tl.label === 'neckline' ? 'rgba(251,191,36,0.8)' : lineColor,
            lineWidth: tl.label === 'neckline' ? 2 : 1.5,
            lineStyle: tl.label === 'neckline' ? 2 : 0, // 2=dashed, 0=solid
            crosshairMarkerVisible: false,
            lastValueVisible: false,
            priceLineVisible: false
          });
          var data = [
            { time: tl.startTime, value: tl.startPrice },
            { time: tl.endTime, value: tl.endPrice }
          ];
          // Ensure data is sorted by time
          data.sort(function(a, b) { return a.time - b.time; });
          lineSeries.setData(data);

          // Add pattern label as a marker on the last point
          if (ti === 0) {
            try {
              lineSeries.setMarkers([{
                time: data[data.length - 1].time,
                position: isBull ? 'belowBar' : 'aboveBar',
                color: isBull ? '#22c55e' : isBear ? '#ef4444' : '#eab308',
                shape: 'square',
                text: pat.name + (pat.completion != null ? ' ' + pat.completion + '%' : '')
              }]);
            } catch(me) {}
          }

          chartPatternSeries.push(lineSeries);
        } catch(e) {
          console.warn('Chart pattern line error:', e);
        }
      }

      // Draw target level as a dotted horizontal line if we have it
      if (pat.target && pat.trendlines.length > 0) {
        try {
          var lastTL = pat.trendlines[pat.trendlines.length - 1];
          if (lastTL.endTime) {
            var targetSeries = chartRef.chart.addLineSeries({
              color: isBull ? 'rgba(34,197,94,0.4)' : isBear ? 'rgba(239,68,68,0.4)' : 'rgba(234,179,8,0.4)',
              lineWidth: 1,
              lineStyle: 2, // dashed
              crosshairMarkerVisible: false,
              lastValueVisible: false,
              priceLineVisible: false
            });
            // Extend target line from pattern end to 20 candles ahead
            var extendTime = lastTL.endTime + (lastTL.endTime - (pat.trendlines[0].startTime || lastTL.startTime)) * 0.5;
            var targetData = [
              { time: lastTL.endTime, value: pat.target },
              { time: Math.max(extendTime, lastTL.endTime + 1), value: pat.target }
            ];
            targetData.sort(function(a, b) { return a.time - b.time; });
            targetSeries.setData(targetData);
            chartPatternSeries.push(targetSeries);
          }
        } catch(te) {
          console.warn('Target line error:', te);
        }
      }
    }
  }

  function loadCandles(tf, opts) {
    opts = opts || {};
    var preserveView = opts.preserveView === true;
    currentTF = tf;
    var tvLoading = document.getElementById('tv-loading');
    var fetchTimeout = setTimeout(function() {
      if (!chartRef.chart && tvLoading && tvLoading.style.display !== 'none') {
        console.warn('Chart fetch timeout, falling back to TradingView');
        showTradingViewFallback();
      }
    }, 15000);
    fetch('/api/candles/' + coinId + '?interval=' + tf)
      .then(function(r) {
        clearTimeout(fetchTimeout);
        if (!r.ok) return r.json().catch(function() { return { success: false }; });
        return r.json();
      })
      .then(function(data) {
        clearTimeout(fetchTimeout);
        if (!data || !data.success || !data.candles || data.candles.length === 0) {
          if (!chartRef.chart) showTradingViewFallback();
          return;
        }

        // Capture pattern data, chart patterns, S/R, POC and SMC from API (redraw per timeframe)
        lastPatterns = data.patterns || [];
        lastChartPatterns = data.chartPatterns || [];
        srLevels.support = data.support;
        srLevels.resistance = data.resistance;
        pocLevel = data.poc != null ? data.poc : null;
        lastOrderBlocks = data.orderBlocks || [];
        lastFVGs = data.fvgs || [];
        lastLiquidityClusters = data.liquidityClusters || {};
        lastVWAP = data.vwap;
        lastSwingPoints = data.swingPoints || { swingLows: [], swingHighs: [] };
        lastMarketStructure = data.marketStructure;
        lastPivotPoints = data.pivotPoints || null;
        lastVolumeProfile = data.volumeProfile || null;

        if (!chartRef.chart) {
          // First load — create the chart (defer so container has layout/dimensions)
          lwContainer.style.display = '';
          tvContainer.style.display = 'none';
          if (tvLoading) tvLoading.style.display = 'none';
          var initRetryCount = 0;
          var MAX_INIT_RETRIES = 20;
          var initTimeout = null;
          var resizeObs = null;
          var initChart = function() {
            try {
              var chartEl = document.getElementById('lw-chart');
              var containerEl = document.getElementById('lw-chart-container');
              if (!chartEl || !containerEl) { showTradingViewFallback(); return; }

              // Use outer container + force reflow (offsetWidth/offsetHeight triggers layout)
              var w = containerEl.offsetWidth || containerEl.clientWidth || chartEl.getBoundingClientRect().width || 0;
              var h = containerEl.offsetHeight || containerEl.clientHeight || chartEl.getBoundingClientRect().height || 0;
              if (w <= 0 || h <= 0) {
                initRetryCount++;
                if (initRetryCount >= MAX_INIT_RETRIES) {
                  var vw = window.innerWidth || 375;
                  var vh = window.innerHeight || 500;
                  w = Math.max(w, Math.min(vw - 32, 400));
                  h = Math.max(h, Math.min(Math.floor(vh * 0.45), 350));
                } else {
                  requestAnimationFrame(function() { requestAnimationFrame(initChart); });
                  return;
                }
              }
              if (resizeObs) { try { resizeObs.disconnect(); } catch(e) {} resizeObs = null; }
              if (initTimeout) { clearTimeout(initTimeout); initTimeout = null; }
              var isMobile = (window.innerWidth || 0) <= 768 || 'ontouchstart' in window;
              var chartOpts = {
                layout: { background: { type: 'solid', color: '#0f172a' }, textColor: '#9ca3af' },
                grid: { vertLines: { color: '#1e293b' }, horzLines: { color: '#1e293b' } },
                timeScale: { timeVisible: true, secondsVisible: false, borderColor: '#334155', shiftVisibleRangeOnNewBar: false },
                rightPriceScale: { borderColor: '#334155', scaleMargins: { top: 0.1, bottom: 0.25 } }
              };
              if (isMobile) {
                chartOpts.width = Math.max(w, 280);
                chartOpts.height = Math.max(h, 250);
                chartOpts.autoSize = false;
              } else if (w > 0 && h > 0) {
                chartOpts.autoSize = true;
              } else {
                chartOpts.width = Math.max(w, 800);
                chartOpts.height = Math.max(h, 400);
                chartOpts.autoSize = false;
              }
              var chart = LightweightCharts.createChart(chartEl, chartOpts);
              var candleColors = getCandleColors();
              var series = chart.addCandlestickSeries({
                upColor: candleColors.up, downColor: candleColors.down,
                borderDownColor: candleColors.down, borderUpColor: candleColors.up,
                wickDownColor: candleColors.down, wickUpColor: candleColors.up
              });
              series.setData(data.candles);
              if (data.volume && data.volume.length > 0) {
                var volSeries = chart.addHistogramSeries({
                  priceFormat: { type: 'volume' },
                  priceScaleId: ''
                });
                try { volSeries.priceScale().applyOptions({ scaleMargins: { top: 0.8, bottom: 0 }, borderVisible: false }); } catch (e) {}
                volSeries.setData(data.volume);
                chartRef.volumeSeries = volSeries;
              }
              chartRef.chart = chart;
              chartRef.series = series;
              chartRef.candleTimes = data.candles.map(function(c) { return c.time; });
              chartRef.candleData = data.candles;
              var lastC = data.candles[data.candles.length - 1];
              lastCandleData = lastC ? { time: lastC.time, open: lastC.open, high: lastC.high, low: lastC.low, close: lastC.close } : null;

              // Price lines and markers (non-critical — errors won't break chart)
              try { addPriceLines(); } catch(e) { console.warn('addPriceLines error:', e); }
              try { applyActionMarkers(initialActions || []); } catch(e) { console.warn('applyActionMarkers error:', e); }
              try { renderChartPatterns(); } catch(e) { console.warn('renderChartPatterns error:', e); }
              try { renderBollingerBands(); } catch(e) { console.warn('renderBollingerBands error:', e); }
              try { renderMALines(); } catch(e) { console.warn('renderMALines error:', e); }
              try { renderKeltnerLines(); } catch(e) { console.warn('renderKeltnerLines error:', e); }
              try { renderDonchianLines(); } catch(e) { console.warn('renderDonchianLines error:', e); }

              chart.timeScale().fitContent();
              startCandleCountdown();
              startCandleAnimation();
              setupCrosshairInfo(chart);
              updateSymbolOverlay(lastC ? lastC.close : null);
              fetch('/api/prices', { credentials: 'same-origin' })
                .then(function(r) { return r.ok ? r.json() : null; })
                .then(function(result) {
                  if (result && result.success && result.data) {
                    var p = result.data.find(function(x) { return x.id === coinId; });
                    if (p && p.price != null) updateSymbolOverlay(Number(p.price), p.change24h);
                  }
                })
                .catch(function() {});
              // Set up drawing overlay after chart is ready
              setTimeout(function() { resizeDrawCanvas(); hookChartRedraw(); }, 100);
              // Mobile portrait fix: force resize after layout settles (candles may not render until container has final dimensions)
              [350, 600, 1000].forEach(function(delay) {
                setTimeout(function() {
                  var c = document.getElementById('lw-chart-container');
                  if (c && chartRef.chart && !tvFallbackAttempted) {
                    var r = c.getBoundingClientRect();
                    if (r.width > 50 && r.height > 50) {
                      try {
                        chartRef.chart.resize(r.width, r.height);
                        chartRef.chart.timeScale().fitContent();
                        resizeDrawCanvas();
                      } catch (e) {}
                    }
                  }
                }, delay);
              });
            } catch (chartErr) {
              console.error('Chart init error:', chartErr);
              showTradingViewFallback();
            }
          };
          var tryInitAttempts = 0;
          var tryInit = function() {
            var containerEl = document.getElementById('lw-chart-container');
            if (!containerEl) return;
            var r = containerEl.getBoundingClientRect();
            if (r.width > 50 && r.height > 50) {
              initChart();
              return;
            }
            tryInitAttempts++;
            if (tryInitAttempts >= 60) {
              initChart();
              return;
            }
            if (typeof requestAnimationFrame === 'function') {
              requestAnimationFrame(function() { requestAnimationFrame(tryInit); });
            } else {
              setTimeout(tryInit, 50);
            }
          };
          if (typeof ResizeObserver !== 'undefined') {
            resizeObs = new ResizeObserver(function() {
              var containerEl = document.getElementById('lw-chart-container');
              if (!containerEl || chartRef.chart) return;
              var r = containerEl.getBoundingClientRect();
              if (r.width > 50 && r.height > 50) {
                if (resizeObs) { try { resizeObs.disconnect(); } catch(e) {} resizeObs = null; }
                if (initTimeout) { clearTimeout(initTimeout); initTimeout = null; }
                initChart();
              }
            });
            resizeObs.observe(lwContainer);
            initTimeout = setTimeout(function() {
              if (!chartRef.chart && resizeObs) {
                resizeObs.disconnect();
                resizeObs = null;
                initTimeout = null;
                initChart();
              }
            }, 3000);
          } else {
            setTimeout(function() {
              if (typeof requestAnimationFrame === 'function') {
                requestAnimationFrame(function() { requestAnimationFrame(tryInit); });
              } else {
                tryInit();
              }
            }, 150);
          }
        } else {
          // Timeframe switch or new-candle refresh — update data
          try {
            chartRef.series.setData(data.candles);
            chartRef.candleTimes = data.candles.map(function(c) { return c.time; });
            chartRef.candleData = data.candles;
            var lastC = data.candles[data.candles.length - 1];
            lastCandleData = lastC ? { time: lastC.time, open: lastC.open, high: lastC.high, low: lastC.low, close: lastC.close } : null;
            if (chartRef.volumeSeries && data.volume && data.volume.length > 0) {
              chartRef.volumeSeries.setData(data.volume);
            }
            try { addPriceLines(); } catch(e) { console.warn('addPriceLines error:', e); }
            try { applyActionMarkers(initialActions || []); } catch(e) { console.warn('applyActionMarkers error:', e); }
            try { renderChartPatterns(); } catch(e) { console.warn('renderChartPatterns error:', e); }
            try { renderBollingerBands(); } catch(e) { console.warn('renderBollingerBands error:', e); }
            try { renderMALines(); } catch(e) { console.warn('renderMALines error:', e); }
            try { renderKeltnerLines(); } catch(e) { console.warn('renderKeltnerLines error:', e); }
            try { renderDonchianLines(); } catch(e) { console.warn('renderDonchianLines error:', e); }
            if (!preserveView) chartRef.chart.timeScale().fitContent();
            startCandleCountdown();
            updateSymbolOverlay(lastC ? lastC.close : null);
            setTimeout(function() { renderDrawings(); }, 100);
          } catch (updateErr) {
            console.error('Chart update error:', updateErr);
          }
        }
      })
      .catch(function(err) {
        clearTimeout(fetchTimeout);
        console.error('Chart load error:', err);
        if (!chartRef.chart) showTradingViewFallback();
      });
  }

  // Fit content / reset zoom button
  var fitBtn = document.getElementById('chart-fit-btn');
  if (fitBtn) {
    fitBtn.addEventListener('click', function() {
      if (chartRef.chart) {
        try { chartRef.chart.timeScale().fitContent(); } catch(e) {}
      }
    });
  }

  // Timeframe button clicks
  var tfBtns = tfSelector ? tfSelector.querySelectorAll('.tf-btn') : [];
  for (var i = 0; i < tfBtns.length; i++) {
    tfBtns[i].addEventListener('click', function() {
      var tf = this.getAttribute('data-tf');
      if (tf === currentTF) return;
      for (var j = 0; j < tfBtns.length; j++) tfBtns[j].classList.remove('tf-active');
      this.classList.add('tf-active');
      loadCandles(tf);
    });
  }

  // Initial load — start immediately so chart loads even if drawing setup fails
  loadCandles('1h');

  // Poll for trade updates when tradeId present (stop moved, actions, etc.)
  if (tradeId && typeof fetch === 'function') {
    var slRow = document.querySelector('.trade-levels-overlay .level-row.sl');
    var slEl = slRow ? slRow.querySelector('.level-price') : null;
    var origEl = slRow ? slRow.querySelector('.level-original') : null;
    var actionsBar = document.getElementById('chart-actions-bar');
    function fmt(n) { return n >= 1 ? n.toFixed(2) : n.toFixed(6); }
    function priceStr(n) { return n >= 1 ? n.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 6}) : n.toFixed(6); }
    setInterval(function() {
      fetch((window.location.origin || '') + '/api/trades/active', { credentials: 'same-origin' })
        .then(function(r) { return r.ok ? r.json() : null; })
        .then(function(data) {
          if (!data || !data.success || !data.trades || !data.trades[tradeId]) return;
          var t = data.trades[tradeId];
          var newSl = t.stopLoss;
          var newOrig = t.originalStopLoss || newSl;
          if (newSl != null && (levels.sl !== newSl || levels.originalSl !== newOrig)) {
            levels.sl = newSl;
            levels.originalSl = newOrig;
            if (slEl) slEl.textContent = '$' + priceStr(newSl);
            if (slRow) {
              if (newOrig != null && newOrig !== newSl) {
                if (!origEl) {
                  origEl = document.createElement('span');
                  origEl.className = 'level-original';
                  slRow.appendChild(origEl);
                }
                origEl.textContent = '(orig: $' + priceStr(newOrig) + ')';
                origEl.style.display = '';
              } else if (origEl) origEl.style.display = 'none';
            }
            if (chartRef.series) {
              if (chartRef.slLine) { try { chartRef.series.removePriceLine(chartRef.slLine); } catch(e) {} chartRef.slLine = null; }
              if (chartRef.origSlLine) { try { chartRef.series.removePriceLine(chartRef.origSlLine); } catch(e) {} chartRef.origSlLine = null; }
              var lineOpts = { lineWidth: 2, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: true };
              chartRef.slLine = chartRef.series.createPriceLine(Object.assign({}, lineOpts, { price: newSl, color: '#ef4444', title: 'SL' }));
              if (newOrig != null && newOrig !== newSl)
                chartRef.origSlLine = chartRef.series.createPriceLine(Object.assign({}, lineOpts, { price: newOrig, color: '#78716c', title: 'Orig SL', lineStyle: LightweightCharts.LineStyle.Dotted }));
            }
          }
          if (t.actions && t.actions.length > 0) {
            // Update chart markers (deduplicated — only latest of each type shown)
            initialActions = t.actions;
            applyActionMarkers(t.actions);

            // Update badge bar (deduplicated — latest of each type)
            if (actionsBar) {
              var latestByType = {};
              t.actions.forEach(function(a) { if (a.type) latestByType[a.type] = a; });
              var deduped = Object.keys(latestByType).map(function(k) { return latestByType[k]; });
              var html = deduped.map(function(a) {
                var dv = '';
                if (['BE','TS','LOCK'].indexOf(a.type) >= 0 && a.newValue != null) {
                  dv = ' $' + fmt(a.newValue);
                } else if (['EXIT','PP','RP'].indexOf(a.type) >= 0 && a.marketPrice != null) {
                  dv = ' @$' + fmt(a.marketPrice);
                }
                var lbl = (a.type || '?') + dv + (a.timestamp ? ' ' + new Date(a.timestamp).toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'}) : '');
                return '<span class="action-badge action-' + (a.type || '').toLowerCase() + '" title="' + (a.description || '').replace(/"/g, '&quot;') + '">' + lbl + '</span>';
              }).join('');
              actionsBar.innerHTML = html;
              actionsBar.style.display = '';
            }
          }
        })
        .catch(function() {});
    }, 5000);
  }

  // ---- Live modify trades: drag SL/TP1/TP2/TP3 to update trade ----
  if (tradeId) {
    var liveModifyCheck = document.getElementById('live-modify-trades');
    var lwChartContainer = document.getElementById('lw-chart-container');
    var lwChart = document.getElementById('lw-chart');
    var dragState = null;
    var HIT_RADIUS = 24;

    function getPriceFromEvent(e) {
      if (!chartRef.series || !lwChart) return null;
      var rect = lwChartContainer.getBoundingClientRect();
      var y = (e.touches && e.touches[0]) ? e.touches[0].clientY : e.clientY;
      y = y - rect.top;
      if (y < 0 || y > rect.height) return null;
      var price = chartRef.series.coordinateToPrice(y);
      return price;
    }

    function findLineAtPrice(clickPrice) {
      if (!chartRef.series || !chartRef.tradeLevelMap) return null;
      var clickY = chartRef.series.priceToCoordinate(clickPrice);
      if (clickY == null) return null;
      var best = null;
      var bestDist = Infinity;
      for (var key in chartRef.tradeLevelMap) {
        var obj = chartRef.tradeLevelMap[key];
        if (!obj || !obj.line) continue;
        var lineY = chartRef.series.priceToCoordinate(obj.price);
        if (lineY == null) continue;
        var dist = Math.abs(clickY - lineY);
        if (dist <= HIT_RADIUS && dist < bestDist) {
          bestDist = dist;
          best = key;
        }
      }
      return best;
    }

    function onModifyMouseDown(e) {
      if (!liveModifyCheck || !liveModifyCheck.checked || !chartRef.chart || !chartRef.series || tvFallbackAttempted) return;
      var price = getPriceFromEvent(e);
      if (price == null) return;
      var key = findLineAtPrice(price);
      if (!key) return;
      e.preventDefault();
      e.stopPropagation();
      dragState = { key: key };
    }

    function onModifyMouseMove(e) {
      if (!dragState || !chartRef.tradeLevelMap || !chartRef.tradeLevelMap[dragState.key]) return;
      var price = getPriceFromEvent(e);
      if (price == null) return;
      var obj = chartRef.tradeLevelMap[dragState.key];
      try {
        obj.line.applyOptions({ price: price });
        obj.price = price;
      } catch (err) {}
    }

    function onModifyMouseUp(e) {
      if (!dragState) return;
      var key = dragState.key;
      dragState = null;
      var obj = chartRef.tradeLevelMap && chartRef.tradeLevelMap[key];
      if (!obj || !tradeId) return;
      var payload = {};
      if (key === 'sl') payload.stopLoss = obj.price;
      else if (key === 'tp1') payload.takeProfit1 = obj.price;
      else if (key === 'tp2') payload.takeProfit2 = obj.price;
      else if (key === 'tp3') payload.takeProfit3 = obj.price;
      if (Object.keys(payload).length === 0) return;
      var csrf = document.getElementById('chart-csrf');
      var headers = { 'Content-Type': 'application/json' };
      if (csrf && csrf.value) headers['X-CSRF-Token'] = csrf.value;
      fetch('/api/trades/' + tradeId + '/levels', {
        method: 'PATCH',
        headers: headers,
        body: JSON.stringify(payload),
        credentials: 'same-origin'
      }).then(function(r) { return r.json();       }).then(function(data) {
        var savedEl = document.getElementById('trade-levels-saved');
        if (data && data.success) {
          if (key === 'sl') levels.sl = obj.price;
          else if (key === 'tp1') levels.tp1 = obj.price;
          else if (key === 'tp2') levels.tp2 = obj.price;
          else if (key === 'tp3') levels.tp3 = obj.price;
          var label = key === 'sl' ? 'SL' : 'TP' + key.charAt(2);
          var rows = document.querySelectorAll('.trade-levels-grid .level-row');
          for (var i = 0; i < rows.length; i++) {
            var nameSpan = rows[i].querySelector('.level-name');
            if (nameSpan && nameSpan.textContent === label) {
              var priceEl = rows[i].querySelector('.level-price');
              if (priceEl) priceEl.textContent = '$' + (obj.price >= 1 ? obj.price.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 6}) : obj.price.toFixed(6));
              break;
            }
          }
          if (savedEl) {
            savedEl.style.display = 'inline';
            savedEl.style.color = '#10b981';
            savedEl.textContent = 'Saved';
            setTimeout(function() { savedEl.style.display = 'none'; }, 2000);
          }
        } else if (savedEl) {
          savedEl.style.display = 'inline';
          savedEl.style.color = '#ef4444';
          savedEl.textContent = 'Save failed';
          setTimeout(function() { savedEl.style.display = 'none'; }, 3000);
        }
      }).catch(function(err) {
        console.warn('Live modify failed:', err);
        var savedEl = document.getElementById('trade-levels-saved');
        if (savedEl) {
          savedEl.style.display = 'inline';
          savedEl.style.color = '#ef4444';
          savedEl.textContent = 'Save failed';
          setTimeout(function() { savedEl.style.display = 'none'; }, 3000);
        }
      });
    }

    if (liveModifyCheck && lwChartContainer) {
      var drawOverlay = document.getElementById('draw-overlay');
      liveModifyCheck.addEventListener('change', function() {
        if (this.checked) {
          lwChartContainer.style.cursor = 'ns-resize';
          lwChartContainer.style.touchAction = 'none';
          if (drawOverlay) drawOverlay.style.pointerEvents = 'none';
        } else {
          lwChartContainer.style.cursor = '';
          lwChartContainer.style.touchAction = '';
          if (drawOverlay) drawOverlay.style.pointerEvents = '';
        }
      });
      if (liveModifyCheck.checked) {
        lwChartContainer.style.touchAction = 'none';
        if (drawOverlay) drawOverlay.style.pointerEvents = 'none';
      }
      var useCapture = true;
      lwChartContainer.addEventListener('mousedown', onModifyMouseDown, useCapture);
      lwChartContainer.addEventListener('touchstart', function(e) { onModifyMouseDown(e); }, { passive: false, capture: true });
      document.addEventListener('mousemove', onModifyMouseMove);
      document.addEventListener('touchmove', function(e) { if (dragState) { e.preventDefault(); onModifyMouseMove(e); } }, { passive: false });
      document.addEventListener('mouseup', onModifyMouseUp);
      document.addEventListener('touchend', function(e) { if (dragState) onModifyMouseUp(e); });
      document.addEventListener('touchcancel', function(e) { if (dragState) { dragState = null; } });
    }
  }

  // ---- Toggle listeners and drawing tools (wrapped so chart load is never blocked) ----
  try {
  var toggleBBEl = document.getElementById('toggle-bb');
  if (toggleBBEl) toggleBBEl.addEventListener('change', function() { toggleBBLines(this.checked); });
  var toggleMAEl = document.getElementById('toggle-ma');
  if (toggleMAEl) toggleMAEl.addEventListener('change', function() { toggleMALines(this.checked); });
  var toggleKeltnerEl = document.getElementById('toggle-keltner');
  if (toggleKeltnerEl) toggleKeltnerEl.addEventListener('change', function() { toggleKeltnerLines(this.checked); });
  var toggleDonchianEl = document.getElementById('toggle-donchian');
  if (toggleDonchianEl) toggleDonchianEl.addEventListener('change', function() { toggleDonchianLines(this.checked); });
  var toggleFibEl = document.getElementById('toggle-fib');
  if (toggleFibEl) toggleFibEl.addEventListener('change', function() { toggleFibLines(this.checked); });
  var toggleBadgesEl = document.getElementById('toggle-badges');
  if (toggleBadgesEl) toggleBadgesEl.addEventListener('change', function() { toggleBadges(this.checked); });
  var togglePatternsEl = document.getElementById('toggle-patterns');
  if (togglePatternsEl) togglePatternsEl.addEventListener('change', function() {
    showPatterns = this.checked;
    applyActionMarkers(initialActions || []);
  });
  var toggleChartPatternsEl = document.getElementById('toggle-chart-patterns');
  if (toggleChartPatternsEl) toggleChartPatternsEl.addEventListener('change', function() {
    showChartPatterns = this.checked;
    if (showChartPatterns) { renderChartPatterns(); } else { removeChartPatternLines(); }
  });
  var toggleSrEl = document.getElementById('toggle-sr');
  if (toggleSrEl) toggleSrEl.addEventListener('change', function() { toggleSRLines(this.checked); });
  var togglePocEl = document.getElementById('toggle-poc');
  if (togglePocEl) togglePocEl.addEventListener('change', function() { togglePOCLines(this.checked); });
  var togglePivotsEl = document.getElementById('toggle-pivots');
  if (togglePivotsEl) togglePivotsEl.addEventListener('change', function() { togglePivotsLines(this.checked); });
  var toggleOBEl = document.getElementById('toggle-ob');
  if (toggleOBEl) toggleOBEl.addEventListener('change', function() { toggleOBLines(this.checked); });
  var toggleFVGEl = document.getElementById('toggle-fvg');
  if (toggleFVGEl) toggleFVGEl.addEventListener('change', function() { toggleFVGLines(this.checked); });
  var toggleLiqEl = document.getElementById('toggle-liq');
  if (toggleLiqEl) toggleLiqEl.addEventListener('change', function() { toggleLiqLines(this.checked); });
  var toggleVWAPEl = document.getElementById('toggle-vwap');
  if (toggleVWAPEl) toggleVWAPEl.addEventListener('change', function() { toggleVWAPLine(this.checked); });
  var togglePremiumEl = document.getElementById('toggle-premium');
  if (togglePremiumEl) togglePremiumEl.addEventListener('change', function() { togglePremiumLines(this.checked); });
  var toggleSwingEl = document.getElementById('toggle-swing');
  if (toggleSwingEl) toggleSwingEl.addEventListener('change', function() { toggleSwingMarkers(this.checked); });
  var toggleStructureEl = document.getElementById('toggle-structure');
  if (toggleStructureEl) toggleStructureEl.addEventListener('change', function() { toggleStructureOverlay(this.checked); });
  var toggleTradeEl = document.getElementById('toggle-trade');
  if (toggleTradeEl) toggleTradeEl.addEventListener('change', function() { toggleTradeLevels(this.checked); });
  var toggleSessionsEl = document.getElementById('toggle-sessions');
  if (toggleSessionsEl) toggleSessionsEl.addEventListener('change', function() { showSessions = this.checked; if (chartRef.series) renderZoneOverlays(); });
  var toggleGapsEl = document.getElementById('toggle-gaps');
  if (toggleGapsEl) toggleGapsEl.addEventListener('change', function() { showGaps = this.checked; if (chartRef.series) renderZoneOverlays(); });
  var toggleVPEl = document.getElementById('toggle-vp');
  if (toggleVPEl) toggleVPEl.addEventListener('change', function() { showVP = this.checked; if (chartRef.series) renderZoneOverlays(); });

  function syncIndicatorCheckboxes() {
    var map = { 'toggle-bb': showBB, 'toggle-ma': showMA, 'toggle-keltner': showKeltner, 'toggle-donchian': showDonchian,
      'toggle-fib': showFib, 'toggle-badges': showBadges, 'toggle-patterns': showPatterns, 'toggle-chart-patterns': showChartPatterns,
      'toggle-sr': showSR, 'toggle-poc': showPOC, 'toggle-pivots': showPivots, 'toggle-trade': showTradeLevels,
      'toggle-ob': showOB, 'toggle-fvg': showFVG, 'toggle-liq': showLiq, 'toggle-vwap': showVWAP,
      'toggle-premium': showPremium, 'toggle-swing': showSwing, 'toggle-structure': showStructure,
      'toggle-sessions': showSessions, 'toggle-gaps': showGaps, 'toggle-vp': showVP };
    for (var id in map) {
      var el = document.getElementById(id);
      if (el) el.checked = map[id];
    }
  }
  function saveIndicatorPrefs() {
    var prefs = { bb: showBB, ma: showMA, keltner: showKeltner, donchian: showDonchian, fib: showFib,
      badges: showBadges, patterns: showPatterns, chartPatterns: showChartPatterns, sr: showSR, poc: showPOC, pivots: showPivots,
      tradeLevels: showTradeLevels, ob: showOB, fvg: showFVG, liq: showLiq, vwap: showVWAP,
      premium: showPremium, swing: showSwing, structure: showStructure, sessions: showSessions, gaps: showGaps, vp: showVP };
    try {
      localStorage.setItem(CHART_INDICATOR_STORAGE_KEY, JSON.stringify(prefs));
    } catch (e) {}
  }
  syncIndicatorCheckboxes();
  var indicatorsSaveBtn = document.getElementById('indicators-save-btn');
  if (indicatorsSaveBtn) {
    indicatorsSaveBtn.addEventListener('click', function() {
      showBB = document.getElementById('toggle-bb') && document.getElementById('toggle-bb').checked;
      showMA = document.getElementById('toggle-ma') && document.getElementById('toggle-ma').checked;
      showKeltner = document.getElementById('toggle-keltner') && document.getElementById('toggle-keltner').checked;
      showDonchian = document.getElementById('toggle-donchian') && document.getElementById('toggle-donchian').checked;
      showFib = document.getElementById('toggle-fib') && document.getElementById('toggle-fib').checked;
      showBadges = document.getElementById('toggle-badges') && document.getElementById('toggle-badges').checked;
      showPatterns = document.getElementById('toggle-patterns') && document.getElementById('toggle-patterns').checked;
      showChartPatterns = document.getElementById('toggle-chart-patterns') && document.getElementById('toggle-chart-patterns').checked;
      showSR = document.getElementById('toggle-sr') && document.getElementById('toggle-sr').checked;
      showPOC = document.getElementById('toggle-poc') && document.getElementById('toggle-poc').checked;
      showPivots = document.getElementById('toggle-pivots') && document.getElementById('toggle-pivots').checked;
      showTradeLevels = (toggleTradeEl && toggleTradeEl.checked) || false;
      showOB = document.getElementById('toggle-ob') && document.getElementById('toggle-ob').checked;
      showFVG = document.getElementById('toggle-fvg') && document.getElementById('toggle-fvg').checked;
      showLiq = document.getElementById('toggle-liq') && document.getElementById('toggle-liq').checked;
      showVWAP = document.getElementById('toggle-vwap') && document.getElementById('toggle-vwap').checked;
      showPremium = document.getElementById('toggle-premium') && document.getElementById('toggle-premium').checked;
      showSwing = document.getElementById('toggle-swing') && document.getElementById('toggle-swing').checked;
      showStructure = document.getElementById('toggle-structure') && document.getElementById('toggle-structure').checked;
      showSessions = document.getElementById('toggle-sessions') && document.getElementById('toggle-sessions').checked;
      showGaps = document.getElementById('toggle-gaps') && document.getElementById('toggle-gaps').checked;
      showVP = document.getElementById('toggle-vp') && document.getElementById('toggle-vp').checked;
      saveIndicatorPrefs();
      if (chartRef.chart) {
        try { addPriceLines(); } catch(e) {}
        try { renderBollingerBands(); } catch(e) {}
        try { renderMALines(); } catch(e) {}
        try { renderKeltnerLines(); } catch(e) {}
        try { renderDonchianLines(); } catch(e) {}
        try { applyActionMarkers(initialActions || []); } catch(e) {}
        try { renderChartPatterns(); } catch(e) {}
        try { renderZoneOverlays(); } catch(e) {}
      }
      indicatorsSaveBtn.textContent = 'Saved!';
      setTimeout(function() { indicatorsSaveBtn.textContent = 'Save Indicators'; }, 1500);
    });
  }
  var candleColorsBtn = document.getElementById('candle-colors-btn');
  var candleColorsPanel = document.getElementById('candle-colors-panel');
  var candleUpInput = document.getElementById('candle-up-color');
  var candleDownInput = document.getElementById('candle-down-color');
  var candleColorsSave = document.getElementById('candle-colors-save');
  var candleColorsReset = document.getElementById('candle-colors-reset');
  if (candleColorsBtn && candleColorsPanel) {
    candleColorsBtn.addEventListener('click', function(e) {
      e.stopPropagation();
      var visible = candleColorsPanel.style.display === 'block';
      candleColorsPanel.style.display = visible ? 'none' : 'block';
      if (!visible) {
        var c = getCandleColors();
        if (candleUpInput) candleUpInput.value = c.up;
        if (candleDownInput) candleDownInput.value = c.down;
      }
    });
    document.addEventListener('click', function() { if (candleColorsPanel) candleColorsPanel.style.display = 'none'; });
    if (candleColorsPanel) candleColorsPanel.addEventListener('click', function(e) { e.stopPropagation(); });
  }
  if (candleUpInput && candleDownInput) {
    function previewCandleColors() {
      var up = candleUpInput.value || CANDLE_DEFAULT_UP;
      var down = candleDownInput.value || CANDLE_DEFAULT_DOWN;
      applyCandleColors(up, down);
    }
    candleUpInput.addEventListener('input', previewCandleColors);
    candleDownInput.addEventListener('input', previewCandleColors);
  }
  if (candleColorsSave && candleUpInput && candleDownInput) {
    candleColorsSave.addEventListener('click', function() {
      var up = candleUpInput.value || CANDLE_DEFAULT_UP;
      var down = candleDownInput.value || CANDLE_DEFAULT_DOWN;
      try {
        localStorage.setItem(CANDLE_STORAGE_KEY_UP, up);
        localStorage.setItem(CANDLE_STORAGE_KEY_DOWN, down);
      } catch (e) {}
      applyCandleColors(up, down);
      if (candleColorsPanel) candleColorsPanel.style.display = 'none';
    });
  }
  if (candleColorsReset && candleUpInput && candleDownInput) {
    candleColorsReset.addEventListener('click', function() {
      candleUpInput.value = CANDLE_DEFAULT_UP;
      candleDownInput.value = CANDLE_DEFAULT_DOWN;
      try {
        localStorage.setItem(CANDLE_STORAGE_KEY_UP, CANDLE_DEFAULT_UP);
        localStorage.setItem(CANDLE_STORAGE_KEY_DOWN, CANDLE_DEFAULT_DOWN);
      } catch (e) {}
      applyCandleColors(CANDLE_DEFAULT_UP, CANDLE_DEFAULT_DOWN);
    });
  }
  var dropdownWraps = document.querySelectorAll('.indicators-dropdown-wrap');
  dropdownWraps.forEach(function(wrap) {
    var btn = wrap.querySelector('.indicators-dropdown-btn');
    if (btn) {
      btn.addEventListener('click', function(e) {
        e.stopPropagation();
        dropdownWraps.forEach(function(w) { if (w !== wrap) w.classList.remove('open'); });
        wrap.classList.toggle('open');
      });
    }
    wrap.addEventListener('click', function(e) { e.stopPropagation(); });
  });
  document.addEventListener('click', function() {
    dropdownWraps.forEach(function(w) { w.classList.remove('open'); });
  });
  var colorInput = document.getElementById('draw-color-input');
  var colorSwatches = document.querySelectorAll('.color-swatch');
  function onColorChange(c) {
    drawColor = c;
    if (colorInput) colorInput.value = c;
    if (selectedIndex != null && drawings[selectedIndex]) {
      drawings[selectedIndex].color = c;
      if (typeof renderDrawings === 'function') renderDrawings();
    }
  }
  if (colorInput) colorInput.addEventListener('input', function() { onColorChange(this.value); });
  for (var si = 0; si < colorSwatches.length; si++) {
    (function(sw) {
      sw.addEventListener('click', function() {
        var c = this.getAttribute('data-color');
        if (c) {
          onColorChange(c);
          for (var sj = 0; sj < colorSwatches.length; sj++) colorSwatches[sj].classList.remove('active');
          this.classList.add('active');
        }
      });
    })(colorSwatches[si]);
  }

  // =============================================
  //  DRAWING TOOLS — canvas overlay system
  // =============================================
  var drawCanvas = document.getElementById('draw-overlay');
  var drawCtx = drawCanvas ? drawCanvas.getContext('2d') : null;
  var drawings = [];       // saved drawings: { type, points (in price/time coords), color }
  function setDrawOverlayPointerEvents(val) {
    var liveMod = document.getElementById('live-modify-trades');
    if (liveMod && liveMod.checked) { if (drawCanvas) drawCanvas.style.pointerEvents = 'none'; return; }
    if (drawCanvas) drawCanvas.style.pointerEvents = val;
  }
  var activeTool = 'cursor';
  var drawState = null;    // in-progress drawing { type, startTime, startPrice, ... }
  var lastValidCoord = null;  // cache last valid t2,p2 so drawing doesn't disappear over price/time scale areas
  var selectedIndex = null;
  var dragState = null;    // { index, startPx, startPy, startT1, startP1, startT2, startP2 } for move

  function resizeDrawCanvas() {
    if (!drawCanvas || !drawCtx || !chartRef.chart) return;
    var container = document.getElementById('lw-chart-container');
    var rect = container.getBoundingClientRect();
    var dpr = window.devicePixelRatio || 1;
    drawCanvas.width = rect.width * dpr;
    drawCanvas.height = rect.height * dpr;
    drawCanvas.style.width = rect.width + 'px';
    drawCanvas.style.height = rect.height + 'px';
    drawCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
    renderDrawings();
    var zonesCanvas = document.getElementById('indicator-zones-canvas');
    if (zonesCanvas) {
      zonesCanvas.width = rect.width * dpr;
      zonesCanvas.height = rect.height * dpr;
      zonesCanvas.style.width = rect.width + 'px';
      zonesCanvas.style.height = rect.height + 'px';
    }
    if (typeof renderZoneOverlays === 'function') renderZoneOverlays();
  }

  // Convert price/time to pixel coordinates
  function toPixel(time, price) {
    if (!chartRef.chart || !chartRef.series) return null;
    var x = chartRef.chart.timeScale().timeToCoordinate(time);
    var y = chartRef.series.priceToCoordinate(price);
    if (x === null || y === null || x === undefined || y === undefined) return null;
    return { x: x, y: y };
  }

  // Convert pixel to price/time (clamp to canvas so long trend lines complete at edges)
  function fromPixel(x, y) {
    if (!chartRef.chart || !chartRef.series) return null;
    var time = chartRef.chart.timeScale().coordinateToTime(x);
    var price = chartRef.series.coordinateToPrice(y);
    if (time == null || price == null) return null;
    return { time: time, price: price };
  }
  function fromPixelClamped(px, py, canvasW, canvasH) {
    var w = canvasW || (drawCanvas ? drawCanvas.getBoundingClientRect().width : 0);
    var h = canvasH || (drawCanvas ? drawCanvas.getBoundingClientRect().height : 0);
    var x = Math.max(0, Math.min(w, px));
    var y = Math.max(0, Math.min(h, py));
    return fromPixel(x, y);
  }

  // Hit test: distance from point to line segment (px, py in pixel coords)
  function distToSegment(px, py, x1, y1, x2, y2) {
    var dx = x2 - x1, dy = y2 - y1;
    var len = Math.sqrt(dx * dx + dy * dy) || 1e-6;
    var t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / (len * len)));
    var nx = x1 + t * dx, ny = y1 + t * dy;
    return Math.sqrt((px - nx) * (px - nx) + (py - ny) * (py - ny));
  }
  function hitTestDrawing(px, py, d, idx) {
    var w = drawCanvas ? drawCanvas.getBoundingClientRect().width : 0;
    var h = drawCanvas ? drawCanvas.getBoundingClientRect().height : 0;
    var hitRadius = 10;
    if (d.type === 'hline') {
      var yPx = chartRef.series.priceToCoordinate(d.price);
      if (yPx == null) return false;
      return Math.abs(py - yPx) <= hitRadius && px >= 0 && px <= w;
    }
    if (d.type === 'trendline') {
      var p1 = toPixel(d.t1, d.p1);
      var p2 = toPixel(d.t2, d.p2);
      if (!p1 || !p2) return false;
      return distToSegment(px, py, p1.x, p1.y, p2.x, p2.y) <= hitRadius;
    }
    if (d.type === 'ray') {
      var rp1 = toPixel(d.t1, d.p1);
      var rp2 = toPixel(d.t2, d.p2);
      if (!rp1 || !rp2) return false;
      var dx = rp2.x - rp1.x, dy = rp2.y - rp1.y;
      var extX = rp2.x + dx * 50, extY = rp2.y + dy * 50;
      return distToSegment(px, py, rp1.x, rp1.y, extX, extY) <= hitRadius && (px - rp1.x) * dx + (py - rp1.y) * dy >= -5;
    }
    if (d.type === 'rect') {
      var rc1 = toPixel(d.t1, d.p1);
      var rc2 = toPixel(d.t2, d.p2);
      if (!rc1 || !rc2) return false;
      var rx = Math.min(rc1.x, rc2.x), ry = Math.min(rc1.y, rc2.y);
      var rw = Math.abs(rc2.x - rc1.x), rh = Math.abs(rc2.y - rc1.y);
      return px >= rx - hitRadius && px <= rx + rw + hitRadius && py >= ry - hitRadius && py <= ry + rh + hitRadius;
    }
    if (d.type === 'fibdraw') {
      var fc1 = toPixel(d.t1, d.p1);
      var fc2 = toPixel(d.t2, d.p2);
      if (!fc1 || !fc2) return false;
      return distToSegment(px, py, fc1.x, fc1.y, fc2.x, fc2.y) <= hitRadius;
    }
    return false;
  }
  // Which drawing is under (px, py)? Top-most first (last in array).
  function getDrawingAt(px, py) {
    for (var i = drawings.length - 1; i >= 0; i--) {
      if (hitTestDrawing(px, py, drawings[i], i)) return i;
    }
    return -1;
  }

  function renderDrawings(tempDraw) {
    if (!drawCtx || !drawCanvas) return;
    var w = drawCanvas.width / (window.devicePixelRatio || 1);
    var h = drawCanvas.height / (window.devicePixelRatio || 1);
    drawCtx.clearRect(0, 0, w, h);

    var all = drawings.slice();
    if (tempDraw) all.push(tempDraw);

    for (var i = 0; i < all.length; i++) {
      var d = all[i];
      var isSelected = (selectedIndex === i && !tempDraw);
      drawCtx.strokeStyle = d.color || '#f59e0b';
      drawCtx.lineWidth = (d.lineWidth || 1.5) + (isSelected ? 2 : 0);
      drawCtx.setLineDash(d.dash || []);
      drawCtx.fillStyle = d.fill || 'transparent';
      drawCtx.font = '10px monospace';

      if (d.type === 'hline') {
        var yPx = chartRef.series.priceToCoordinate(d.price);
        if (yPx == null) continue;
        drawCtx.beginPath();
        drawCtx.moveTo(0, yPx);
        drawCtx.lineTo(w, yPx);
        drawCtx.stroke();
        // Price label
        drawCtx.fillStyle = d.color || '#f59e0b';
        var lbl = d.price >= 1 ? d.price.toFixed(2) : d.price.toFixed(6);
        drawCtx.fillText(lbl, 4, yPx - 4);
        drawCtx.fillStyle = 'transparent';

      } else if (d.type === 'trendline') {
        var p1 = toPixel(d.t1, d.p1);
        var p2 = toPixel(d.t2, d.p2);
        if (!p1 || !p2) continue;
        drawCtx.beginPath();
        drawCtx.moveTo(p1.x, p1.y);
        drawCtx.lineTo(p2.x, p2.y);
        drawCtx.stroke();
        // Small anchor dots
        drawCtx.fillStyle = d.color || '#f59e0b';
        drawCtx.beginPath(); drawCtx.arc(p1.x, p1.y, 3, 0, Math.PI * 2); drawCtx.fill();
        drawCtx.beginPath(); drawCtx.arc(p2.x, p2.y, 3, 0, Math.PI * 2); drawCtx.fill();
        drawCtx.fillStyle = 'transparent';

      } else if (d.type === 'ray') {
        var rp1 = toPixel(d.t1, d.p1);
        var rp2 = toPixel(d.t2, d.p2);
        if (!rp1 || !rp2) continue;
        var dx = rp2.x - rp1.x;
        var dy = rp2.y - rp1.y;
        var extX = rp2.x + dx * 50;
        var extY = rp2.y + dy * 50;
        drawCtx.beginPath();
        drawCtx.moveTo(rp1.x, rp1.y);
        drawCtx.lineTo(extX, extY);
        drawCtx.stroke();
        drawCtx.fillStyle = d.color || '#f59e0b';
        drawCtx.beginPath(); drawCtx.arc(rp1.x, rp1.y, 3, 0, Math.PI * 2); drawCtx.fill();
        drawCtx.fillStyle = 'transparent';

      } else if (d.type === 'rect') {
        var rc1 = toPixel(d.t1, d.p1);
        var rc2 = toPixel(d.t2, d.p2);
        if (!rc1 || !rc2) continue;
        var rx = Math.min(rc1.x, rc2.x);
        var ry = Math.min(rc1.y, rc2.y);
        var rw = Math.abs(rc2.x - rc1.x);
        var rh = Math.abs(rc2.y - rc1.y);
        drawCtx.fillStyle = (d.color || '#f59e0b') + '18';
        drawCtx.fillRect(rx, ry, rw, rh);
        drawCtx.strokeRect(rx, ry, rw, rh);
        drawCtx.fillStyle = 'transparent';

      } else if (d.type === 'fibdraw') {
        var highPrice = Math.max(d.p1, d.p2);
        var lowPrice = Math.min(d.p1, d.p2);
        var range = highPrice - lowPrice;
        var fibRatios = [
          { r: 0, label: '0%', color: '#6b7280' },
          { r: 0.236, label: '23.6%', color: '#a78bfa' },
          { r: 0.382, label: '38.2%', color: '#a78bfa' },
          { r: 0.5,   label: '50%',   color: '#c084fc' },
          { r: 0.618, label: '61.8%', color: '#e879f9' },
          { r: 0.786, label: '78.6%', color: '#f472b6' },
          { r: 1,     label: '100%',  color: '#6b7280' }
        ];
        for (var fi = 0; fi < fibRatios.length; fi++) {
          var fib = fibRatios[fi];
          var fibPrice = highPrice - range * fib.r;
          var fibY = chartRef.series.priceToCoordinate(fibPrice);
          if (fibY == null) continue;
          drawCtx.strokeStyle = fib.color;
          drawCtx.setLineDash([4, 4]);
          drawCtx.lineWidth = 1;
          drawCtx.beginPath();
          drawCtx.moveTo(0, fibY);
          drawCtx.lineTo(w, fibY);
          drawCtx.stroke();
          // Label
          drawCtx.fillStyle = fib.color;
          var fibLbl = fib.label + ' – ' + (fibPrice >= 1 ? fibPrice.toFixed(2) : fibPrice.toFixed(6));
          drawCtx.fillText(fibLbl, 4, fibY - 4);
        }
        // Shaded zone between 0.5 and 0.618
        var y50 = chartRef.series.priceToCoordinate(highPrice - range * 0.5);
        var y618 = chartRef.series.priceToCoordinate(highPrice - range * 0.618);
        if (y50 != null && y618 != null) {
          drawCtx.fillStyle = 'rgba(192,132,252,0.08)';
          drawCtx.fillRect(0, Math.min(y50, y618), w, Math.abs(y618 - y50));
        }
        drawCtx.setLineDash([]);
        drawCtx.fillStyle = 'transparent';
        drawCtx.strokeStyle = d.color || '#f59e0b';
        drawCtx.lineWidth = 1.5;
      }
    }
    drawCtx.setLineDash([]);
  }

  // Re-render drawings whenever chart pans/zooms
  function hookChartRedraw() {
    if (!chartRef.chart) return;
    chartRef.chart.timeScale().subscribeVisibleLogicalRangeChange(function() {
      renderDrawings();
      if (typeof renderZoneOverlays === 'function') renderZoneOverlays();
    });
    chartRef.chart.subscribeCrosshairMove(function() { /* lightweight redraw on move if drawing */ });
  }

  function updateDeleteButton() {
    var btn = document.getElementById('draw-delete-btn');
    if (btn) {
      btn.disabled = selectedIndex == null;
      btn.style.opacity = selectedIndex != null ? '1' : '0.5';
      btn.style.cursor = selectedIndex != null ? 'pointer' : 'not-allowed';
    }
  }

  // Tool button clicks (wrapped so chart load is never blocked)
  var toolBtns = [];
  toolBtns = document.querySelectorAll('#draw-tools .tool-btn');
  for (var ti = 0; ti < toolBtns.length; ti++) {
    toolBtns[ti].addEventListener('click', function() {
      var tool = this.getAttribute('data-tool');
      if (tool === 'clear') {
        if (drawings.length === 0) return;
        if (!confirm('Clear all ' + drawings.length + ' drawing(s)?')) return;
        drawings = [];
        drawState = null;
        lastValidCoord = null;
        selectedIndex = null;
        dragState = null;
        setDrawOverlayPointerEvents('none');
        renderDrawings();
        updateDeleteButton();
        return;
      }
      if (tool === 'delete') {
        if (selectedIndex != null && drawings[selectedIndex]) {
          drawings.splice(selectedIndex, 1);
          selectedIndex = null;
          dragState = null;
          if (drawings.length === 0) setDrawOverlayPointerEvents('none');
          renderDrawings();
          updateDeleteButton();
        }
        return;
      }
      activeTool = tool;
      drawState = null;
      lastValidCoord = null;
      dragState = null;
      if (tool === 'cursor') selectedIndex = null;
      for (var tj = 0; tj < toolBtns.length; tj++) toolBtns[tj].classList.remove('tool-active');
      this.classList.add('tool-active');
      if (drawCanvas) {
        if (tool === 'cursor') {
          setDrawOverlayPointerEvents(drawings.length > 0 ? 'auto' : 'none');
          drawCanvas.style.cursor = 'default';
        } else {
          setDrawOverlayPointerEvents('auto');
          drawCanvas.style.cursor = 'crosshair';
        }
      }
      renderDrawings();
      updateDeleteButton();
    });
  }

  // Get pointer coords from mouse or touch (for mobile press-and-drag)
  function getPointerCoords(e) {
    var t = (e.touches && e.touches.length > 0) ? e.touches[0] : (e.changedTouches && e.changedTouches.length > 0) ? e.changedTouches[0] : e;
    return { clientX: t.clientX, clientY: t.clientY };
  }
  function handlePointerDown(e) {
    var coords = getPointerCoords(e);
    var rect = drawCanvas.getBoundingClientRect();
    var x = coords.clientX - rect.left;
    var y = coords.clientY - rect.top;
      var w = rect.width;
      var h = rect.height;

      if (activeTool === 'cursor') {
        var idx = getDrawingAt(x, y);
        if (idx >= 0) {
          // Hit a drawing → select it and start drag
          selectedIndex = idx;
          var d = drawings[idx];
          if (d.type === 'hline') {
            dragState = { index: idx, startPx: x, startPy: y, origP1: d.price };
          } else {
            dragState = { index: idx, startPx: x, startPy: y, origT1: d.t1, origP1: d.p1, origT2: d.t2, origP2: d.p2 };
          }
          renderDrawings();
          updateDeleteButton();
        } else {
          // Missed all drawings → deselect and let chart handle the click
          selectedIndex = null;
          dragState = null;
          renderDrawings();
          updateDeleteButton();
          setDrawOverlayPointerEvents('none');
          setTimeout(function() {
            if (activeTool === 'cursor' && drawCanvas && drawings.length > 0) setDrawOverlayPointerEvents('auto');
          }, 300);
        }
        return;
      }

      var coord = fromPixelClamped(x, y, w, h);
      if (!coord) return;

      if (activeTool === 'hline') {
        drawings.push({ type: 'hline', price: coord.price, color: drawColor, lineWidth: 1.5 });
        activeTool = 'cursor';
        selectedIndex = drawings.length - 1;
        setDrawOverlayPointerEvents(drawings.length > 0 ? 'auto' : 'none');
        if (drawCanvas) drawCanvas.style.cursor = 'default';
        for (var th = 0; th < toolBtns.length; th++) {
          toolBtns[th].classList.remove('tool-active');
          if (toolBtns[th].getAttribute('data-tool') === 'cursor') toolBtns[th].classList.add('tool-active');
        }
        renderDrawings();
        updateDeleteButton();
        return;
      }

      drawState = { type: activeTool, t1: coord.time, p1: coord.price };
      lastValidCoord = { time: coord.time, price: coord.price };
  }
  if (drawCanvas) {
  drawCanvas.addEventListener('mousedown', handlePointerDown);
  drawCanvas.addEventListener('touchstart', function(e) {
    if (activeTool !== 'cursor' || drawings.length > 0) e.preventDefault();
    handlePointerDown(e);
  }, { passive: false });

  function handlePointerMove(e) {
      var coords = getPointerCoords(e);
      var rect = drawCanvas.getBoundingClientRect();
      var x = coords.clientX - rect.left;
      var y = coords.clientY - rect.top;
      var w = rect.width;
      var h = rect.height;

      if (dragState !== null) {
        var now = fromPixel(x, y);
        var start = fromPixel(dragState.startPx, dragState.startPy);
        if (now && start) {
          var dt = now.time - start.time;
          var dp = now.price - start.price;
          var d = drawings[dragState.index];
          if (d.type === 'hline') {
            d.price = dragState.origP1 + dp;
          } else {
            d.t1 = dragState.origT1 + dt;
            d.p1 = dragState.origP1 + dp;
            d.t2 = dragState.origT2 + dt;
            d.p2 = dragState.origP2 + dp;
          }
          dragState.startPx = x;
          dragState.startPy = y;
          dragState.origP1 = d.type === 'hline' ? d.price : d.p1;
          if (d.type !== 'hline') {
            dragState.origT1 = d.t1;
            dragState.origP1 = d.p1;
            dragState.origT2 = d.t2;
            dragState.origP2 = d.p2;
          }
        }
        renderDrawings();
        return;
      }

      if (drawState) {
        var coord = fromPixelClamped(x, y, w, h);
        if (coord) lastValidCoord = { time: coord.time, price: coord.price };
        var t2 = coord ? coord.time : (lastValidCoord ? lastValidCoord.time : null);
        var p2 = coord ? coord.price : (lastValidCoord ? lastValidCoord.price : null);
        if (t2 != null && p2 != null) {
          var temp = Object.assign({}, drawState, { t2: t2, p2: p2, color: drawColor, lineWidth: 1.5 });
          renderDrawings(temp);
        } else {
          renderDrawings();
        }
      }
    }
    drawCanvas.addEventListener('mousemove', handlePointerMove);
    drawCanvas.addEventListener('touchmove', function(e) {
      if (dragState || drawState) e.preventDefault();
      handlePointerMove(e);
    }, { passive: false });

    function handlePointerUp(e) {
      var coords = getPointerCoords(e);
      var rect = drawCanvas.getBoundingClientRect();
      var x = coords.clientX - rect.left;
      var y = coords.clientY - rect.top;
      var w = rect.width;
      var h = rect.height;
      if (dragState !== null) {
        dragState = null;
        return;
      }
      if (!drawState) return;
      var coord = fromPixelClamped(x, y, w, h);
      if (!coord) {
        if (lastValidCoord) {
          coord = lastValidCoord;
        } else {
          drawState = null;
          lastValidCoord = null;
          renderDrawings();
          return;
        }
      }

      var d = Object.assign({}, drawState, { t2: coord.time, p2: coord.price, color: drawColor, lineWidth: 1.5 });
      drawings.push(d);
      drawState = null;
      lastValidCoord = null;

      // Auto-switch back to cursor mode after placing a drawing (like TradingView)
      activeTool = 'cursor';
      selectedIndex = drawings.length - 1; // select the just-drawn item
      if (drawCanvas) {
        setDrawOverlayPointerEvents(drawings.length > 0 ? 'auto' : 'none');
        drawCanvas.style.cursor = 'default';
      }
      for (var tb = 0; tb < toolBtns.length; tb++) {
        toolBtns[tb].classList.remove('tool-active');
        if (toolBtns[tb].getAttribute('data-tool') === 'cursor') toolBtns[tb].classList.add('tool-active');
      }
      renderDrawings();
      updateDeleteButton();
    }
    drawCanvas.addEventListener('mouseup', handlePointerUp);
    drawCanvas.addEventListener('touchend', function(e) {
      if (dragState || drawState) e.preventDefault();
      handlePointerUp(e);
    }, { passive: false });
    drawCanvas.addEventListener('touchcancel', function(e) {
      if (dragState || drawState) e.preventDefault();
      drawState = null;
      lastValidCoord = null;
      dragState = null;
      renderDrawings();
    }, { passive: false });
  }
  } catch (drawErr) {
    console.warn('Drawing tools init:', drawErr);
  }
  document.addEventListener('keydown', function(e) {
    if (e.key === 'Delete' || e.key === 'Backspace') {
      if (selectedIndex != null && drawings[selectedIndex]) {
        e.preventDefault();
        drawings.splice(selectedIndex, 1);
        selectedIndex = null;
        dragState = null;
        if (drawings.length === 0) setDrawOverlayPointerEvents('none');
        renderDrawings();
        updateDeleteButton();
      }
      return;
    }
    if (e.key === 'Escape') {
      drawState = null;
      lastValidCoord = null;
      dragState = null;
      selectedIndex = null;
      renderDrawings();
      activeTool = 'cursor';
      if (drawCanvas) {
        setDrawOverlayPointerEvents('none');
        drawCanvas.style.cursor = 'default';
      }
      for (var tk = 0; tk < toolBtns.length; tk++) {
        toolBtns[tk].classList.remove('tool-active');
        if (toolBtns[tk].getAttribute('data-tool') === 'cursor') toolBtns[tk].classList.add('tool-active');
      }
      updateDeleteButton();
    }
  });
  updateDeleteButton();

  window.addEventListener('resize', function() { forceChartResize(); resizeDrawCanvas(); });

  // Mobile: force chart resize on orientation change (fixes candles not showing in portrait until rotate)
  function forceChartResize() {
    if (!chartRef.chart || tvFallbackAttempted) return;
    var container = document.getElementById('lw-chart-container');
    if (!container) return;
    var rect = container.getBoundingClientRect();
    if (rect.width > 0 && rect.height > 0) {
      try {
        chartRef.chart.resize(rect.width, rect.height);
        chartRef.chart.timeScale().fitContent();
      } catch (e) {}
    }
    resizeDrawCanvas();
  }
  window.addEventListener('orientationchange', function() {
    setTimeout(forceChartResize, 100);
  });
  if (window.visualViewport) {
    window.visualViewport.addEventListener('resize', function() { forceChartResize(); });
  }
  document.addEventListener('visibilitychange', function() {
    if (document.visibilityState === 'visible') setTimeout(forceChartResize, 150);
  });

})();
</script>

<%- include('partials/footer') %>
